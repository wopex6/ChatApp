<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatApp - Message Ken Tse</title>
    
    <!-- Mobile Console for iPhone Debugging -->
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 100%;
            max-width: 900px;
            height: 90vh;
            max-height: 800px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            display: none;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .auth-section {
            max-width: 400px;
            margin: 0 auto;
            overflow-y: auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            margin-top: 10px;
        }

        .chat-section {
            display: none;
            flex: 1;
            min-height: 0;
        }
        
        .chat-section[style*="display: block"],
        .chat-section[style*="display: flex"] {
            display: flex !important;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            position: relative;
            height: 100%;
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 2px solid #e1e8ed;
            background: white;
            position: sticky;
            top: 0;
            z-index: 100;
            flex-shrink: 0;
        }

        .chat-header h2 {
            color: #333;
        }

        .btn-logout {
            background: #f5576c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .messages-container {
            flex: 1;
            min-height: 50vh;
            overflow-y: auto;
            overflow-x: visible;
            padding: 20px 16px;
            background: #E5DDD5;
            border-radius: 0;
            margin: 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 60%;
            word-wrap: break-word;
            display: inline-block;
            width: fit-content;
            box-shadow: 0 1px 0.5px rgba(0,0,0,0.13);
            position: relative;
        }
        
        .message-wrapper .message {
            position: relative;
        }

        .message.received {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            align-self: flex-start;
        }

        .message.sent-by-me {
            background: #DCF8C6;
            color: #000;
            border-bottom-right-radius: 2px;
            margin-left: auto;
            float: right;
            clear: both;
        }
        
        .message.sent-by-me.unread {
            background: #FFFF00;
        }

        .message.sent-by-other {
            background: #FFFFFF;
            border: none;
            border-bottom-left-radius: 2px;
            color: #000;
            float: left;
            clear: both;
        }

        .message-sender {
            font-size: 0.85em;
            opacity: 0.8;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .message-time {
            font-size: 0.7em;
            color: rgba(0,0,0,0.45);
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
            gap: 3px;
        }
        
        .message-tick {
            display: inline-block;
            font-size: 0.85em;
            color: #8696a0;
        }
        
        .message.sent-by-me .message-tick {
            color: #8696a0;
        }

        .date-separator {
            text-align: center;
            margin: 20px 0;
            color: #8696a0;
            font-size: 0.8em;
            font-weight: 500;
            background: rgba(255,255,255,0.9);
            padding: 5px 12px;
            border-radius: 8px;
            display: inline-block;
            box-shadow: 0 1px 0.5px rgba(0,0,0,0.13);
        }

        .message-input-container {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message-input-wrapper {
            flex: 1;
        }

        .message-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 1em;
            outline: none;
            transition: border-color 0.3s;
            resize: none;
            min-height: 45px;
            max-height: 120px;
            overflow-y: auto;
            line-height: 1.5;
            font-family: inherit;
        }
        
        .message-input::-webkit-scrollbar {
            width: 6px;
        }
        
        .message-input::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .message-input::-webkit-scrollbar-thumb {
            background: #8696a0;
            border-radius: 3px;
        }
        
        .message-input::-webkit-scrollbar-thumb:hover {
            background: #667781;
        }

        .input-section {
            display: flex;
            gap: 10px;
            padding: 20px;
            background: white;
            border-top: 1px solid #e1e8ed;
            position: sticky;
            bottom: 0;
            z-index: 100;
            flex-shrink: 0;
        }
        
        .input-actions {
            display: flex;
            gap: 2.5px !important;
            align-items: center;
        }

        .btn-send {
            padding: 8px;
            background: transparent;
            color: #667eea;
            border: none;
            cursor: pointer;
            font-size: 24px;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-send:hover {
            transform: scale(1.1);
        }

        .btn-attachment {
            padding: 8px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s;
        }

        .btn-attachment:hover {
            background: #f0f3f5;
            transform: translateY(-2px);
        }

        .emoji-picker {
            position: absolute;
            bottom: 70px;
            right: 80px;
            background: white;
            border: 2px solid #e1e8ed;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: none;
            z-index: 1000;
            max-width: 280px;
        }

        .emoji-picker.active {
            display: block;
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .emoji-item {
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 6px;
            text-align: center;
            transition: all 0.2s;
        }

        .emoji-item:hover {
            background: #f0f3f5;
            transform: scale(1.2);
        }

        .file-input {
            display: none;
        }

        .file-preview {
            margin-top: 10px;
            padding: 10px;
            background: #f7f9fa;
            border-radius: 8px;
            display: none;
        }

        .file-preview.show {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-preview-name {
            flex: 1;
            font-size: 0.9em;
            color: #333;
        }

        .file-preview-remove {
            background: #f5576c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
        }

        .message-attachment {
            margin-top: 10px;
        }

        .message-attachment img {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            cursor: pointer;
        }

        .message-attachment video {
            max-width: 400px;
            max-height: 300px;
            border-radius: 8px;
        }

        .message-attachment audio {
            width: 100%;
            max-width: 400px;
        }

        .file-download {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f7f9fa;
            border-radius: 6px;
            text-decoration: none;
            color: #333;
            font-size: 0.9em;
            margin-top: 8px;
        }

        .file-download:hover {
            background: #e1e8ed;
        }

        .error-message {
            background: #ffe5e5;
            color: #d32f2f;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }

        .success-message {
            background: #e5ffe5;
            color: #2f7d32;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            flex: 1;
            padding: 10px;
            background: #f7f9fa;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .admin-section {
            display: none;
            width: 450px;
            flex-shrink: 0;
            flex-direction: column;
            height: calc(100vh - 120px);
            position: relative;
            margin-right: 0;
            min-height: 0;
            overflow: hidden;
        }
        
        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 5px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.2s;
            z-index: 10;
        }
        
        .resize-handle:hover,
        .resize-handle.dragging {
            background: #667eea;
        }

        .user-list,
        #all-users-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            margin-bottom: 20px;
            min-height: 0;
        }
        
        .user-list::-webkit-scrollbar,
        #all-users-list::-webkit-scrollbar,
        .messages-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .user-list::-webkit-scrollbar-track,
        #all-users-list::-webkit-scrollbar-track,
        .messages-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .user-list::-webkit-scrollbar-thumb,
        #all-users-list::-webkit-scrollbar-thumb,
        .messages-container::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }
        
        .user-list::-webkit-scrollbar-thumb:hover,
        #all-users-list::-webkit-scrollbar-thumb:hover,
        .messages-container::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }

        .user-item {
            padding: 15px;
            background: #f7f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            position: relative;
        }

        .user-item:hover {
            background: #e1e8ed;
            transform: translateX(5px);
        }

        .user-item.active {
            background: #667eea;
            color: white;
        }

        .user-item.deleted {
            opacity: 0.5;
            text-decoration: line-through;
        }

        .user-item-info {
            flex: 1;
        }

        .user-item-actions {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 0.85em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
        }

        .btn-delete {
            background: #f5576c;
            color: white;
        }

        .btn-restore {
            background: #4caf50;
            color: white;
        }

        .btn-permanent {
            background: #d32f2f;
            color: white;
        }

        .unread-badge {
            background: #f5576c;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            margin-left: 10px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .password-wrapper {
            position: relative;
        }
        
        .password-toggle-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 0.85em;
            padding: 4px 8px;
            border-radius: 3px;
        }
        
        .password-toggle-btn:hover {
            background-color: #f0f0f0;
        }
        
        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn-cancel {
            background: #e1e8ed;
            color: #333;
        }

        .settings-section {
            display: none;
            padding: 20px;
            background: #f7f9fa;
            border-radius: 10px;
        }

        .admin-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        
        #admin-conversations-tab,
        #admin-users-tab {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
            height: 100%;
        }
        
        #admin-conversations-tab h3,
        #admin-users-tab h3 {
            margin-bottom: 15px;
            flex-shrink: 0;
        }
        
        #admin-conversations-tab > *:not(h3),
        #admin-users-tab > *:not(h3) {
            min-height: 0;
        }

        .admin-tab {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .admin-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .message.sent {
            background: #DCF8C6;
        }
        
        .message-wrapper {
            position: relative;
            display: block;
            margin-bottom: 15px;
            width: 100%;
            overflow: visible;
        }
        
        .message-wrapper.mine,
        .message-wrapper.sent-by-me {
            text-align: right;
        }
        
        .message-wrapper.sent-by-other {
            text-align: left;
        }
        
        .message-actions {
            display: none;
            gap: 4px;
            position: absolute;
            right: auto;
            left: 100%;
            top: 0;
            margin-left: 5px;
            background: white;
            padding: 3px 5px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .message-wrapper.mine .message-actions,
        .message-wrapper.sent-by-me .message-actions {
            left: auto;
            right: 100%;
            margin-left: 0;
            margin-right: 5px;
        }
        
        .message:hover .message-actions {
            display: flex !important;
        }
        
        .message-actions button {
            background: rgba(255,255,255,0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s;
        }
        
        .message-actions button:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .reply-bar {
            display: none;
            background: #f0f0f0;
            padding: 10px 15px;
            border-left: 3px solid #667eea;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        
        .reply-bar.show {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .reply-preview {
            background: rgba(0, 0, 0, 0.05);
            border-left: 4px solid #06cf9c;
            padding: 6px 10px;
            margin-bottom: 6px;
            border-radius: 4px;
            font-size: 0.85em;
            color: #667781;
        }
        
        /* Voice Call Styles */
        .call-button {
            background: #4caf50;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 18px;
            border-radius: 50%;
            transition: all 0.2s;
            flex-shrink: 0;
            min-width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .call-button:hover {
            transform: scale(1.1);
            background: #45a049;
        }
        
        .call-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #cccccc;
        }
        
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.85em;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        
        .status-online {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .status-offline {
            background: #ffebee;
            color: #c62828;
        }
        
        .status-in-call {
            background: #e3f2fd;
            color: #1565c0;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .dot-online { background: #4caf50; }
        .dot-offline { background: #f44336; }
        .dot-in-call { background: #2196f3; animation: pulse 1.5s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .call-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        .call-modal.show {
            display: flex;
        }
        
        .call-modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .call-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            color: white;
            animation: ringPulse 2s infinite;
        }
        
        @keyframes ringPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .call-info h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 1.5em;
        }
        
        .call-status {
            color: #666;
            font-size: 0.95em;
            margin-bottom: 20px;
        }
        
        .call-timer {
            font-size: 1.2em;
            color: #667eea;
            font-weight: 600;
            margin: 15px 0;
        }
        
        .call-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }
        
        .call-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 1.5em;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .call-btn:hover {
            transform: scale(1.1);
        }
        
        .btn-answer {
            background: #4caf50;
            color: white;
        }
        
        .btn-reject, .btn-hangup {
            background: #f44336;
            color: white;
        }
        
        .btn-mute {
            background: #757575;
            color: white;
        }
        
        .btn-mute.active {
            background: #ff9800;
        }
        
        .btn-video {
            background: #2196f3;
            color: white;
        }
        
        .btn-video.active {
            background: #4caf50;
        }
        
        /* Video Call Styles */
        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            height: 480px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin: 0 auto 20px;
        }
        
        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .local-video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid white;
            object-fit: cover;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        /* Mobile responsive video */
        @media (max-width: 768px) {
            /* Mobile: Stack admin panel and chat vertically */
            .container > div > div:first-child {
                flex-direction: column !important;
            }
            
            /* Admin panel takes less height on mobile */
            #admin-panel {
                width: 100% !important;
                max-height: 40vh;
                overflow-y: auto;
                border-right: none !important;
                border-bottom: 2px solid #667eea;
            }
            
            /* User list items on mobile */
            .user-item {
                padding: 12px;
                font-size: 0.9em;
            }
            
            .user-name {
                font-size: 0.95em;
            }
            
            .last-message-time {
                font-size: 0.75em;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 150px;
            }
            
            /* Call button visible on mobile */
            .call-button {
                min-width: 36px;
                height: 36px;
                font-size: 16px;
                padding: 6px;
                flex-shrink: 0;
                margin-left: auto;
            }
            
            /* Messages container takes remaining space */
            .messages-container {
                flex: 1;
                max-height: 60vh;
            }
            
            /* Chat area visible indicator on mobile */
            #chat-area {
                border-left: 3px solid #667eea;
            }
            
            /* Messages title always visible on mobile */
            #messages-title {
                display: block !important;
                position: sticky;
                top: 0;
                z-index: 10;
            }
            
            /* Video calls on mobile */
            .video-container {
                height: 300px;
                max-width: 100%;
            }
            
            .local-video {
                width: 100px;
                height: 75px;
                bottom: 10px;
                right: 10px;
            }
            
            .call-controls {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .call-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2em;
            }
            
            /* Hide resize handle on mobile */
            .resize-handle {
                display: none !important;
            }
        }
        
        .missed-calls-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #f44336;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.75em;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }
        
        .missed-calls-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .missed-call-item {
            padding: 12px;
            background: #fff3e0;
            border-left: 3px solid #ff9800;
            margin-bottom: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .missed-call-item.seen {
            background: #f5f5f5;
            border-left-color: #bdbdbd;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üí¨ ChatApp</h1>
            <p id="header-subtitle" style="display: none;">Message with Ken Tse</p>
        </div>

        <div class="content">
            <!-- Login Section -->
            <div id="auth-section" class="auth-section">
                <div class="tabs">
                    <button class="tab active" onclick="showLogin()">Login</button>
                    <button class="tab" onclick="showSignup()">Sign Up</button>
                </div>

                <!-- Login Form -->
                <form id="login-form" autocomplete="on" onsubmit="event.preventDefault(); login();">
                    <div class="form-group">
                        <label>Username</label>
                        <input type="text" id="login-username" name="username" 
                               placeholder="Enter username" autocomplete="username" required>
                    </div>
                    <div class="form-group">
                        <label>Password</label>
                        <div class="password-wrapper">
                            <input type="password" id="login-password" name="password" 
                                   placeholder="Enter password" autocomplete="current-password" style="padding-right: 60px;" required>
                            <button type="button" class="password-toggle-btn" onclick="togglePasswordVisibility('login-password', this)">
                                Show
                            </button>
                        </div>
                    </div>
                    <button class="btn" type="submit">Login</button>
                </form>

                <!-- Signup Form -->
                <form id="signup-form" style="display: none;" autocomplete="on" onsubmit="event.preventDefault(); signup();">
                    <div class="form-group">
                        <label>Username</label>
                        <input type="text" id="signup-username" name="username" 
                               placeholder="Choose username" autocomplete="username">
                    </div>
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="signup-email" name="email" 
                               placeholder="Enter email" autocomplete="email">
                    </div>
                    <div class="form-group">
                        <label>Password</label>
                        <div class="password-wrapper">
                            <input type="password" id="signup-password" name="new-password" 
                                   placeholder="Choose password" autocomplete="new-password" style="padding-right: 60px;">
                            <button type="button" class="password-toggle-btn" onclick="togglePasswordVisibility('signup-password', this)">
                                Show
                            </button>
                        </div>
                    </div>
                    <button class="btn" type="submit">Sign Up</button>
                </form>
                
                <!-- Error/Success Messages (outside forms, visible on both tabs) -->
                <div id="error-message" class="error-message" style="margin-top: 15px;"></div>
                <div id="success-message" class="success-message" style="margin-top: 15px;"></div>
            </div>

            <!-- Chat Section -->
            <div id="chat-section" class="chat-section" style="display: none;">
                <div class="chat-header">
                    <div>
                        <h2 id="chat-title"></h2>
                        <p id="user-info" style="color: #666; margin-top: 5px;"></p>
                        <div id="admin-status-indicator" style="margin-top: 8px; display: none;"></div>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button id="call-admin-btn" class="call-button" onclick="initiateCall()" style="display: none;">
                            üìû Call
                        </button>
                        <div id="missed-calls-indicator" style="position: relative; display: none;">
                            <button class="btn-logout" style="background: #ff9800;" onclick="showMissedCalls()">
                                üîî Missed Calls
                            </button>
                            <span id="missed-calls-count" class="missed-calls-badge" style="display: none;">0</span>
                        </div>
                        <button class="btn-logout" style="background: #667eea;" onclick="showSettings()">‚öôÔ∏è Settings</button>
                        <button class="btn-logout" onclick="logout()">Logout</button>
                    </div>
                </div>

                <div style="display: flex; flex: 1; overflow: hidden;">
                    <!-- Admin Panel (only for Ken Tse) -->
                    <div id="admin-panel" class="admin-section">
                    <div class="resize-handle" id="resize-handle"></div>
                    <div class="admin-tabs">
                        <button class="admin-tab active" onclick="showAdminTab('conversations')">üí¨ Conversations</button>
                        <button class="admin-tab" onclick="showAdminTab('users')">üë• <span id="users-tab-label">Users</span></button>
                    </div>
                    
                    <div id="admin-conversations-tab">
                        <h3 style="margin-bottom: 15px;">User Conversations</h3>
                        <div id="user-list" class="user-list"></div>
                    </div>
                    
                    <div id="admin-users-tab" style="display: none;">
                        <h3 style="margin-bottom: 15px;">User Management</h3>
                        <div style="margin-bottom: 15px; display: flex; gap: 10px; align-items: center;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="show-deleted-toggle" onchange="toggleShowDeleted()" 
                                       style="width: 18px; height: 18px; cursor: pointer;">
                                <span style="font-size: 0.95em;">Show Deleted Users</span>
                            </label>
                            <button class="btn" style="padding: 8px 16px; font-size: 0.9em; margin-left: auto; background: #dc3545;" 
                                    onclick="bulkDeleteUsers()">
                                üóëÔ∏è Remove All Deleted
                            </button>
                        </div>
                        <div id="all-users-list" class="user-list"></div>
                    </div>
                    </div>

                    <!-- Main Chat Area -->
                    <div id="chat-area" style="flex: 1; display: flex; flex-direction: column; min-width: 0; background: #fff;">
                        <!-- Messages Title Bar (visible on mobile) -->
                        <div id="messages-title" style="display: none; padding: 10px 15px; background: #667eea; color: white; font-weight: 600; border-bottom: 2px solid #5568d3;">
                            <span id="chat-username">Select a user</span>
                        </div>
                        
                        <!-- Messages -->
                        <div id="messages-container" class="messages-container">
                            <div class="loading">Loading messages...</div>
                        </div>

                        <!-- Reply Bar -->
                        <div id="reply-bar" class="reply-bar">
                            <div>
                                <div style="font-size: 0.85em; color: #667eea; font-weight: 600;">Replying to:</div>
                                <div id="reply-preview" style="margin-top: 4px;"></div>
                            </div>
                            <button onclick="cancelReply()" style="background: none; border: none; cursor: pointer; font-size: 1.2em;">‚úñ</button>
                        </div>

                        <!-- Message Input -->
                        <div id="message-input-section" class="input-section">
                            <textarea id="message-input" class="message-input" 
                                   placeholder="Type your message..." 
                                   rows="1"
                                   oninput="autoResizeTextarea(this)"
                                   onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"></textarea>
                            <div class="input-actions">
                                <button class="btn-attachment" onclick="document.getElementById('file-input').click()">üìé</button>
                                <button class="btn-attachment" onclick="toggleEmojiPicker()">üòä</button>
                                <button class="btn-send" onclick="sendMessage()">‚û§</button>
                                <input type="file" id="file-input" style="display: none;" onchange="handleFileSelect(event)">
                            </div>
                            <!-- Emoji Picker -->
                            <div id="emoji-picker" class="emoji-picker">
                                <div id="emoji-grid" class="emoji-grid"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Change Password Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <h3>‚öôÔ∏è Settings</h3>
            
            <h4 style="margin-top: 20px; margin-bottom: 10px;">Change Password</h4>
            <form onsubmit="event.preventDefault(); changePassword();">
                <div class="form-group">
                    <label>Current Password</label>
                    <div class="password-wrapper">
                        <input type="password" id="current-password" name="current-pwd" 
                               placeholder="Enter current password" 
                               autocomplete="current-password" 
                               data-form-type="other" style="padding-right: 60px;">
                        <button type="button" class="password-toggle-btn" onclick="togglePasswordVisibility('current-password', this)">
                            Show
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>New Password</label>
                    <div class="password-wrapper">
                        <input type="password" id="new-password" name="new-pwd" 
                               placeholder="Enter new password (min 6 characters)" 
                               autocomplete="new-password" 
                               data-form-type="other" style="padding-right: 60px;">
                        <button type="button" class="password-toggle-btn" onclick="togglePasswordVisibility('new-password', this)">
                            Show
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Confirm New Password</label>
                    <div class="password-wrapper">
                        <input type="password" id="confirm-password" name="confirm-pwd" 
                               placeholder="Confirm new password" 
                               autocomplete="off" 
                               data-form-type="other" style="padding-right: 60px;">
                        <button type="button" class="password-toggle-btn" onclick="togglePasswordVisibility('confirm-password', this)">
                            Show
                        </button>
                    </div>
                    <!-- Dedicated error/success message space -->
                    <div id="settings-error-message" class="error-message" style="display: none; margin-top: 10px;"></div>
                    <div id="settings-success-message" class="success-message" style="display: none; margin-top: 10px;"></div>
                </div>
                <div class="modal-actions" style="margin-top: 20px;">
                    <button type="submit" class="btn">Change Password</button>
                    <button type="button" class="btn btn-cancel" onclick="closeSettings()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirm-modal" class="modal">
        <div class="modal-content">
            <h3 id="confirm-title">Confirm Action</h3>
            <p id="confirm-message"></p>
            <div class="modal-actions">
                <button class="btn btn-delete" id="confirm-btn" onclick="confirmAction()">Confirm</button>
                <button class="btn btn-cancel" onclick="closeConfirmModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Voice Call Modals -->
    
    <!-- Incoming Call Modal -->
    <div id="incoming-call-modal" class="call-modal">
        <div class="call-modal-content">
            <div class="call-avatar">
                <span id="incoming-caller-icon">üìû</span>
            </div>
            <div class="call-info">
                <h3 id="incoming-caller-name">Incoming Call</h3>
                <div class="call-status">Ringing...</div>
            </div>
            <div class="call-controls">
                <button class="call-btn btn-answer" onclick="answerCall()" title="Answer">
                    üìû
                </button>
                <button class="call-btn btn-reject" onclick="rejectCall()" title="Reject">
                    ‚úñ
                </button>
            </div>
        </div>
    </div>

    <!-- Active Call Modal -->
    <div id="active-call-modal" class="call-modal">
        <div class="call-modal-content">
            <!-- Video Container -->
            <div id="video-container" class="video-container" style="display: none;">
                <video id="remote-video" class="remote-video" autoplay playsinline style="cursor: pointer;" title="Single tap: swap | Double tap: fullscreen"></video>
                <video id="local-video" class="local-video" autoplay playsinline muted style="cursor: pointer;" title="Single tap: swap | Double tap: fullscreen"></video>
            </div>
            
            <!-- Audio/Avatar View -->
            <div id="audio-view" class="call-avatar" style="animation: none;">
                <span id="active-call-icon">üìû</span>
            </div>
            
            <div class="call-info">
                <h3 id="active-call-name">In Call</h3>
                <div class="call-status" id="active-call-status">Connected</div>
                <div class="call-timer" id="call-timer">00:00</div>
            </div>
            <div class="call-controls">
                <button class="call-btn btn-video" id="video-btn" onclick="toggleVideo()" title="Toggle Video">
                    üìπ
                </button>
                <button class="call-btn btn-mute" id="mute-btn" onclick="toggleMute()" title="Mute">
                    üîá
                </button>
                <button class="call-btn btn-hangup" onclick="hangupCall()" title="Hang Up">
                    ‚òéÔ∏è
                </button>
            </div>
            <!-- Hidden audio element for remote stream -->
            <audio id="remote-audio" autoplay></audio>
        </div>
    </div>

    <script>
        // Use the current host (works on both localhost and network IP)
        const API_URL = `${window.location.protocol}//${window.location.host}/api`;
        let token = null;  // Don't auto-load token - require explicit login
        let currentUser = null;
        let selectedUserId = null;
        let messageInterval = null;
        let adminMessageInterval = null;  // Separate interval for admin message view
        let selectedFile = null;
        let replyToId = null;  // Track message being replied to
        
        // Voice call variables
        let heartbeatInterval = null;
        let currentCallId = null;
        let currentCallState = null;  // 'calling', 'ringing', 'connected', 'ended'
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let callStartTime = null;
        let callTimerInterval = null;
        let signalPollInterval = null;
        let callTimeoutTimer = null;  // For call timeout handling
        let remoteUserId = null; // Track who we're in a call with for hangup signaling
        let adminId = null;  // Will be set on login

        // Emoji list
        const emojis = ['üòÄ','üòÉ','üòÑ','üòÅ','üòÜ','üòÖ','ü§£','üòÇ','üôÇ','üôÉ','üòâ','üòä','üòá','ü•∞','üòç','ü§©','üòò','üòó','üòö','üòô','ü•≤','üòã','üòõ','üòú','ü§™','üòù','ü§ë','ü§ó','ü§≠','ü§´','ü§î','ü§ê','ü§®','üòê','üòë','üò∂','üòè','üòí','üôÑ','üò¨','ü§•','üòå','üòî','üò™','ü§§','üò¥','üò∑','ü§í','ü§ï','ü§¢','ü§Æ','ü§ß','ü•µ','ü•∂','ü•¥','üòµ','ü§Ø','ü§†','ü•≥','ü•∏','üòé','ü§ì','üßê','üòï','üòü','üôÅ','‚òπÔ∏è','üòÆ','üòØ','üò≤','üò≥','ü•∫','üò¶','üòß','üò®','üò∞','üò•','üò¢','üò≠','üò±','üòñ','üò£','üòû','üòì','üò©','üò´','ü•±','üò§','üò°','üò†','ü§¨','üëç','üëé','üëä','‚úä','ü§õ','ü§ú','ü§û','‚úåÔ∏è','ü§ü','ü§ò','üëå','ü§å','ü§è','üëà','üëâ','üëÜ','üëá','‚òùÔ∏è','‚úã','ü§ö','üñêÔ∏è','üññ','üëã','ü§ô','üí™','üôè','‚ù§Ô∏è','üß°','üíõ','üíö','üíô','üíú','üñ§','ü§ç','ü§é','üíî','‚ù£Ô∏è','üíï','üíû','üíì','üíó','üíñ','üíò','üíù','üéâ','üéä','üéà','üéÅ','üèÜ','ü•á','ü•à','ü•â','‚≠ê','üåü','‚ú®','üí´','üî•','üíØ','‚úÖ','‚ùå','‚ö†Ô∏è','üìå','üìç','üîî','üîï','üì¢','üì£'];
        
        // Populate emoji picker
        function initEmojiPicker() {
            const grid = document.getElementById('emoji-grid');
            if (grid) {
                grid.innerHTML = emojis.map(emoji => 
                    `<span class="emoji-item" onclick="insertEmoji('${emoji}')">${emoji}</span>`
                ).join('');
            }
        }
        
        function toggleEmojiPicker() {
            const picker = document.getElementById('emoji-picker');
            if (picker) {
                picker.classList.toggle('active');
            }
        }
        
        function insertEmoji(emoji) {
            const input = document.getElementById('message-input');
            if (input) {
                input.value += emoji;
                input.focus();
            }
            // Keep picker open for multiple emoji selection
        }
        
        // Close emoji picker when clicking outside
        document.addEventListener('click', function(event) {
            const picker = document.getElementById('emoji-picker');
            if (!picker) return;
            
            const emojiButton = event.target.closest('.btn-attachment');
            
            if (picker.classList.contains('active') && 
                !picker.contains(event.target) && 
                !emojiButton) {
                picker.classList.remove('active');
            }
        });
        
        // Initialize emoji picker when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initEmojiPicker);
        } else {
            initEmojiPicker();
        }

        // Initialize
        // DON'T auto-login - require explicit login each time
        // Clear any existing token on page load to prevent auto-login
        localStorage.removeItem('chatapp_token');
        
        // Clean up any old Remember Me data
        localStorage.removeItem('chatapp_saved_username');
        localStorage.removeItem('chatapp_saved_password');
        localStorage.removeItem('chatapp_remember_me');
        

        function showError(message) {
            // Check if settings modal is open
            const settingsModal = document.getElementById('settings-modal');
            if (settingsModal && settingsModal.classList.contains('show')) {
                // Show only in settings modal - don't auto-hide
                const settingsError = document.getElementById('settings-error-message');
                const settingsSuccess = document.getElementById('settings-success-message');
                settingsSuccess.style.display = 'none'; // Hide success if showing
                settingsError.textContent = message;
                settingsError.style.display = 'block';
                // Don't auto-hide - stays until next action
            } else {
                // Show in main error area
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                setTimeout(() => errorDiv.style.display = 'none', 5000);
            }
        }

        function showSuccess(message) {
            // Check if settings modal is open
            const settingsModal = document.getElementById('settings-modal');
            if (settingsModal && settingsModal.classList.contains('show')) {
                // Show only in settings modal
                const settingsError = document.getElementById('settings-error-message');
                const settingsSuccess = document.getElementById('settings-success-message');
                settingsError.style.display = 'none'; // Hide error if showing
                settingsSuccess.textContent = message;
                settingsSuccess.style.display = 'block';
                setTimeout(() => settingsSuccess.style.display = 'none', 3000);
            } else {
                // Show in main success area
                const successDiv = document.getElementById('success-message');
                successDiv.textContent = message;
                successDiv.style.display = 'block';
                setTimeout(() => successDiv.style.display = 'none', 3000);
            }
        }

        // ========== Device & Browser Detection ==========
        
        function detectDevice() {
            const ua = navigator.userAgent;
            const device = {
                isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua),
                isIOS: /iPhone|iPad|iPod/i.test(ua),
                isAndroid: /Android/i.test(ua),
                isChrome: /Chrome/i.test(ua) && !/Edge/i.test(ua),
                isSafari: /Safari/i.test(ua) && !/Chrome/i.test(ua),
                isFirefox: /Firefox/i.test(ua),
                isEdge: /Edge/i.test(ua),
                browser: '',
                os: '',
                screenWidth: window.innerWidth,
                screenHeight: window.innerHeight,
                orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait'
            };
            
            // Determine browser
            if (device.isChrome) device.browser = 'Chrome';
            else if (device.isSafari) device.browser = 'Safari';
            else if (device.isFirefox) device.browser = 'Firefox';
            else if (device.isEdge) device.browser = 'Edge';
            else device.browser = 'Unknown';
            
            // Determine OS
            if (device.isIOS) device.os = 'iOS';
            else if (device.isAndroid) device.os = 'Android';
            else if (ua.indexOf('Win') !== -1) device.os = 'Windows';
            else if (ua.indexOf('Mac') !== -1) device.os = 'macOS';
            else if (ua.indexOf('Linux') !== -1) device.os = 'Linux';
            else device.os = 'Unknown';
            
            return device;
        }
        
        const deviceInfo = detectDevice();
        
        // Log device info immediately
        console.log('\ud83d\udcf1 ========== DEVICE INFO ==========');
        console.log('Device Type:', deviceInfo.isMobile ? 'MOBILE' : 'PC');
        console.log('OS:', deviceInfo.os);
        console.log('Browser:', deviceInfo.browser);
        console.log('Screen:', `${deviceInfo.screenWidth}x${deviceInfo.screenHeight}`);
        console.log('Orientation:', deviceInfo.orientation);
        console.log('User Agent:', navigator.userAgent);
        console.log('==================================\n');
        
        // Enhanced debug logger
        function debugLog(category, message, data = null) {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const deviceType = deviceInfo.isMobile ? 'üì±' : 'üñ•Ô∏è';
            const prefix = `${deviceType} [${timestamp}] [${category}]`;
            
            if (data) {
                console.log(`${prefix} ${message}`, data);
            } else {
                console.log(`${prefix} ${message}`);
            }
        }
        
        function showLogin() {
            document.getElementById('login-form').style.display = 'block';
            document.getElementById('signup-form').style.display = 'none';
            document.querySelectorAll('.tab')[0].classList.add('active');
            document.querySelectorAll('.tab')[1].classList.remove('active');
        }

        function showSignup() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('signup-form').style.display = 'block';
            document.querySelectorAll('.tab')[0].classList.remove('active');
            document.querySelectorAll('.tab')[1].classList.add('active');
        }

        async function login() {
            const username = document.getElementById('login-username').value;
            const password = document.getElementById('login-password').value;

            if (!username || !password) {
                showError('Please enter username and password');
                return;
            }

            try {
                const response = await fetch(`${API_URL}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });

                const data = await response.json();

                if (response.ok) {
                    token = data.token;
                    localStorage.setItem('chatapp_token', token);
                    currentUser = data.user;
                    
                    // Get admin ID for voice calls from login response
                    if (currentUser.role !== 'administrator' && data.admin_id) {
                        adminId = data.admin_id;
                        console.log('Admin ID set to:', adminId);
                    }
                    
                    showChatSection();
                    
                    // Start heartbeat for status tracking
                    startHeartbeat();
                    
                    // Start signal polling for incoming calls (CRITICAL FIX)
                    startSignalPolling();
                    console.log('‚úÖ Signal polling started for incoming calls');
                    
                    // Load missed calls if admin
                    if (currentUser.role === 'administrator') {
                        loadMissedCalls();
                        setInterval(loadMissedCalls, 30000); // Check every 30 seconds
                    }
                } else {
                    showError(data.error || 'Login failed');
                }
            } catch (error) {
                showError('Connection error. Make sure server is running on port 5001');
            }
        }

        async function signup() {
            const username = document.getElementById('signup-username').value;
            const email = document.getElementById('signup-email').value;
            const password = document.getElementById('signup-password').value;

            if (!username || !email || !password) {
                showError('Please fill all fields');
                return;
            }

            try {
                const response = await fetch(`${API_URL}/auth/signup`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, email, password })
                });

                const data = await response.json();

                if (response.ok) {
                    token = data.token;
                    localStorage.setItem('chatapp_token', token);
                    currentUser = data.user;
                    showSuccess('Account created successfully!');
                    showChatSection();
                } else {
                    showError(data.error || 'Signup failed');
                }
            } catch (error) {
                showError('Connection error. Make sure server is running on port 5001');
            }
        }

        async function checkAuth() {
            try {
                const response = await fetch(`${API_URL}/auth/user`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    currentUser = await response.json();
                    showChatSection();
                } else {
                    logout();
                }
            } catch (error) {
                logout();
            }
        }

        async function updateUserWelcomeMessage() {
            // For regular users, show: "Welcome <user>, <admin> is <status>" (but hide "Online")
            const adminDisplayName = localStorage.getItem(`admin_name_for_user_${currentUser.id}`) || 'Ken';
            const status = await getUserStatus(adminId);
            
            let statusText = '';
            switch (status.status) {
                case 'online':
                    // Show "is" but no status word after it
                    statusText = ' is';
                    break;
                case 'in_call':
                    statusText = ' is Not Available';
                    break;
                default:
                    statusText = ' is Offline';
            }
            
            document.getElementById('user-info').textContent = `Welcome ${currentUser.username}, ${adminDisplayName}${statusText}`;
        }

        function showChatSection() {
            document.getElementById('auth-section').style.display = 'none';
            document.getElementById('chat-section').style.display = 'flex'; // Changed to flex

            if (currentUser.role === 'administrator') {
                document.getElementById('user-info').textContent = `Logged in as: ${currentUser.username}`;
                document.getElementById('header-subtitle').textContent = 'Admin Dashboard';
                document.getElementById('chat-title').textContent = '';
                const adminPanel = document.getElementById('admin-panel');
                adminPanel.style.display = 'flex'; // Changed to flex for proper layout
                // Restore saved width for conversations tab
                adminPanel.style.width = tabWidths.conversations;
                document.getElementById('message-input-section').style.display = 'none'; // Hide until user selected
                document.getElementById('messages-container').innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">Select a user to view conversation</p>';
                
                // Show missed calls indicator for admin
                document.getElementById('missed-calls-indicator').style.display = 'block';
                
                loadUserList();
                messageInterval = setInterval(loadUserList, 10000); // Auto-refresh user list
                
                // Poll for incoming call signals (fast polling for better responsiveness)
                signalPollInterval = setInterval(pollSignals, 300); // Poll every 300ms
            } else {
                // Get custom admin name for this user
                const adminDisplayName = localStorage.getItem(`admin_name_for_user_${currentUser.id}`) || 'Ken';
                document.getElementById('header-subtitle').textContent = `Chat with ${adminDisplayName}`;
                document.getElementById('admin-panel').style.display = 'none'; // Hide admin panel for regular users
                document.getElementById('message-input-section').style.display = 'flex';
                
                // Show call button for regular users
                const callBtn = document.getElementById('call-admin-btn');
                if (callBtn) {
                    callBtn.style.display = 'inline-block';
                    callBtn.disabled = false; // Ensure button is enabled on login
                }
                
                // Update welcome message with admin status
                updateUserWelcomeMessage();
                setInterval(updateUserWelcomeMessage, 15000); // Update every 15s
                
                // Update admin status indicator
                if (adminId) {
                    updateStatusIndicator(adminId);
                    setInterval(() => updateStatusIndicator(adminId), 15000); // Update every 15s
                }
                
                loadMessages();
                messageInterval = setInterval(loadMessages, 5000); // Auto-refresh every 5s
                
                // Poll for incoming call signals (fast polling for better responsiveness)
                signalPollInterval = setInterval(pollSignals, 300); // Poll every 300ms
            }
        }

        // Helper function to parse timestamps reliably across all browsers (iOS, Android, etc.)
        // Displays times in the client's local timezone
        function parseTimestamp(timestamp) {
            if (!timestamp) return null;
            
            try {
                let isoString = timestamp;
                
                // If format is "YYYY-MM-DD HH:MM:SS", convert to "YYYY-MM-DDTHH:MM:SS"
                if (timestamp.includes(' ') && !timestamp.includes('T')) {
                    isoString = timestamp.replace(' ', 'T');
                }
                // If format is "YYYY-MM-DD HH:MM:SS.ffffff", handle microseconds
                else if (timestamp.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+$/)) {
                    // Remove microseconds for better browser compatibility
                    const withoutMicro = timestamp.replace(/\.\d+$/, '');
                    isoString = withoutMicro.replace(' ', 'T');
                }
                
                // For Safari compatibility, ensure we don't have timezone issues
                // If no timezone specified, treat as local time
                if (!isoString.includes('Z') && !isoString.includes('+') && !isoString.includes('-', 10)) {
                    // Parse as local time components
                    const parts = isoString.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/);
                    if (parts) {
                        const date = new Date(
                            parseInt(parts[1]), // year
                            parseInt(parts[2]) - 1, // month (0-indexed)
                            parseInt(parts[3]), // day
                            parseInt(parts[4]), // hour
                            parseInt(parts[5]), // minute
                            parseInt(parts[6])  // second
                        );
                        
                        if (!isNaN(date.getTime())) {
                            return date;
                        }
                    }
                }
                
                // Fallback to standard parsing
                const date = new Date(isoString);
                
                // Validate the date
                if (isNaN(date.getTime())) {
                    console.error('Invalid date:', timestamp);
                    return null;
                }
                
                return date;
            } catch (error) {
                console.error('Date parsing error:', timestamp, error);
                return null;
            }
        }

        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            
            const date = parseTimestamp(timestamp);
            if (!date) {
                console.warn('formatTimestamp: Could not parse timestamp:', timestamp);
                return '';
            }
            
            try {
                const now = new Date();
                const diff = now - date;
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const time = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
                
                if (days === 0) {
                    // Today - show "Today" + time
                    return `Today ${time}`;
                } else if (days === 1) {
                    // Yesterday - show "Yesterday" + time
                    return `Yesterday ${time}`;
                } else if (days < 7) {
                    // This week - show weekday + date + time
                    const weekday = date.toLocaleDateString([], { weekday: 'short' });
                    const dateStr = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                    return `${weekday}, ${dateStr} ${time}`;
                } else if (days < 365) {
                    // This year - show month + day + time
                    const dateStr = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                    return `${dateStr} ${time}`;
                } else {
                    // Older than a year - show full date + time
                    const dateStr = date.toLocaleDateString([], { year: 'numeric', month: 'short', day: 'numeric' });
                    return `${dateStr} ${time}`;
                }
            } catch (error) {
                console.error('formatTimestamp error:', error, timestamp);
                return '';
            }
        }

        async function loadUserList() {
            try {
                const response = await fetch(`${API_URL}/admin/users`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const users = await response.json();
                const userListDiv = document.getElementById('user-list');
                
                if (users.length === 0) {
                    userListDiv.innerHTML = '<div class="no-users">No users yet</div>';
                    return;
                }
                
                userListDiv.innerHTML = '';
                users.forEach(user => {
                    const userDiv = document.createElement('div');
                    userDiv.className = 'user-item';
                    userDiv.onclick = () => selectUser(user.id, user.username);
                    
                    // Show unread badge if there are messages
                    const unreadBadge = user.unread_count > 0 ? 
                        `<span class="unread-badge">${user.unread_count}</span>` : '';
                    
                    // Show last message time if exists, otherwise show "New user"
                    const timeDisplay = user.last_message_time ? 
                        formatTimestamp(user.last_message_time) : 
                        '<span style="color: #999; font-size: 11px;">New user</span>';
                    
                    userDiv.innerHTML = `
                        <div class="user-info">
                            <div class="user-name">${user.username}</div>
                            <div class="last-message-time">${timeDisplay}</div>
                        </div>
                        ${unreadBadge}
                        <button class="call-button" onclick="event.stopPropagation(); callUser(${user.id}, '${user.username.replace(/'/g, "\\'")}')">üìû</button>
                    `;
                    userListDiv.appendChild(userDiv);
                });
            } catch (error) {
                showError('Failed to load conversations');
            }
        }

        async function selectUser(userId, username) {
            selectedUserId = userId;
            document.getElementById('chat-title').textContent = '';
            document.getElementById('message-input-section').style.display = 'flex'; // Show input when user selected
            
            // Show messages title bar (especially helpful on mobile)
            const messagesTitle = document.getElementById('messages-title');
            const chatUsername = document.getElementById('chat-username');
            if (messagesTitle) messagesTitle.style.display = 'block';
            if (chatUsername) chatUsername.textContent = `Chat with ${username}`;
            
            // Clear any existing admin message interval
            if (adminMessageInterval) {
                console.log('[Admin] Clearing previous message refresh interval');
                clearInterval(adminMessageInterval);
            }
            
            // Load messages immediately
            await loadUserMessages(userId);
            
            // Mark messages as read by admin
            try {
                await fetch(`${API_URL}/admin/users/${userId}/mark-read`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                console.log(`[Admin] Marked user ${userId} messages as read`);
            } catch (error) {
                console.error('Failed to mark messages as read:', error);
            }
            
            // Refresh user list IMMEDIATELY to update unread count badge
            await loadUserList();
            
            // Set up auto-refresh for this user's messages every 5 seconds
            console.log(`[Admin] Setting up auto-refresh for user ${userId} messages (every 5 seconds)`);
            adminMessageInterval = setInterval(() => {
                if (selectedUserId === userId) {  // Only refresh if still viewing same user
                    console.log(`[Admin] Auto-refreshing messages for user ${userId}`);
                    loadUserMessages(userId);
                }
            }, 5000);
        }

        async function loadUserMessages(userId) {
            try {
                console.log(`[Admin] Loading messages for user ${userId}`);
                const response = await fetch(`${API_URL}/admin/users/${userId}/messages`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                const messages = await response.json();
                console.log(`[Admin] Loaded ${messages.length} messages for user ${userId}`);
                displayMessages(messages);
            } catch (error) {
                console.error('Failed to load messages:', error);
                showError('Failed to load messages');
            }
        }

        async function loadMessages() {
            try {
                console.log('[Auto-Refresh] Checking for new messages...');
                const response = await fetch(`${API_URL}/messages`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                const messages = await response.json();
                console.log(`[Auto-Refresh] Loaded ${messages.length} messages`);
                displayMessages(messages);
            } catch (error) {
                console.error('Failed to load messages:', error);
            }
        }

        function displayMessages(messages) {
            const container = document.getElementById('messages-container');
            
            if (messages.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">No messages yet. Start the conversation!</p>';
                return;
            }

            let lastDate = null;
            let html = '';
            
            messages.forEach((msg, index) => {
                const msgDate = parseTimestamp(msg.timestamp);
                if (!msgDate) return; // Skip invalid dates
                
                const dateStr = msgDate.toLocaleDateString();
                const timeStr = msgDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }).toLowerCase();
                
                // Check if date changed
                if (dateStr !== lastDate) {
                    const options = { weekday: 'short', day: 'numeric', month: 'short' };
                    const formattedDate = msgDate.toLocaleDateString('en-US', options);
                    html += `<div style="text-align: center; margin: 20px 0;"><div class="date-separator">${formattedDate}</div></div>`;
                    lastDate = dateStr;
                }
                
                // Determine if this message is from current viewer
                let isMine = false;
                let senderName = '';
                
                if (currentUser.role === 'administrator') {
                    // Admin viewing: admin messages are "mine", user messages are "other"
                    isMine = msg.sender_type === 'admin';
                    senderName = isMine ? '' : (msg.username || ''); // Don't show 'You' or 'User'
                } else {
                    // Regular user viewing: user messages are "mine", admin messages are "other"
                    isMine = msg.sender_type === 'user';
                    senderName = ''; // Don't show any sender name for users
                }
                
                const messageClass = isMine ? 'sent-by-me' : 'sent-by-other';
                const attachmentHtml = msg.file_url ? renderAttachment(msg.file_url, msg.file_name, msg.file_size) : '';
                
                // Reply preview if message has reply_to
                let replyHtml = '';
                if (msg.reply_to) {
                    const replyToMsg = messages.find(m => m.id === msg.reply_to);
                    if (replyToMsg) {
                        const replyText = replyToMsg.message || 'Attachment';
                        replyHtml = `<div class="reply-preview">‚Ü© ${replyText.substring(0, 50)}${replyText.length > 50 ? '...' : ''}</div>`;
                    }
                }
                
                // No tick mark - background color indicates read status
                let tickMark = '';
                
                // Add unread class for sent messages that haven't been read
                const unreadClass = (isMine && !msg.is_read) ? 'unread' : '';
                
                html += `
                    <div class="message-wrapper ${messageClass}">
                        <div class="message ${messageClass} ${unreadClass}">
                            ${senderName ? `<div class="message-sender">${senderName}</div>` : ''}
                            ${replyHtml}
                            <div>
                                ${msg.message || '<em>Sent an attachment</em>'}
                                <span class="message-time">${timeStr}${tickMark}</span>
                            </div>
                            ${attachmentHtml}
                            <div class="message-actions">
                                <button onclick="replyToMessage(${msg.id}, '${(msg.message || 'Attachment').replace(/'/g, "\\'")}')">‚Ü©</button>
                                ${isMine ? `<button onclick="deleteMessage(${msg.id})">üóë</button>` : ''}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;

            container.scrollTop = container.scrollHeight;
            
            // Mark messages as read if user view
            if (currentUser && currentUser.role !== 'administrator') {
                markMessagesAsRead();
            }
        }

        function renderAttachment(fileUrl, fileName, fileSize) {
            if (!fileUrl) return '';
            
            const extension = fileName ? fileName.split('.').pop().toLowerCase() : '';
            const sizeText = fileSize ? formatFileSize(fileSize) : '';
            
            // Image files
            if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(extension)) {
                return `
                    <div class="message-attachment">
                        <img src="${fileUrl}" alt="${fileName}" onclick="window.open('${fileUrl}', '_blank')">
                        <div style="font-size: 0.85em; margin-top: 5px; opacity: 0.8; display: flex; justify-content: space-between; align-items: center;">
                            <span>${fileName} (${sizeText})</span>
                            <a href="${fileUrl}?original_name=${encodeURIComponent(fileName)}" download="${fileName}" style="margin-left: 10px; text-decoration: none;">üì•</a>
                        </div>
                    </div>
                `;
            }
            
            // Video files
            if (['mp4', 'webm', 'mov', 'avi'].includes(extension)) {
                return `
                    <div class="message-attachment">
                        <video controls>
                            <source src="${fileUrl}" type="video/${extension === 'mov' ? 'quicktime' : extension}">
                            Your browser doesn't support video playback.
                        </video>
                        <div style="font-size: 0.85em; margin-top: 5px; opacity: 0.8; display: flex; justify-content: space-between; align-items: center;">
                            <span>${fileName} (${sizeText})</span>
                            <a href="${fileUrl}?original_name=${encodeURIComponent(fileName)}" download="${fileName}" style="margin-left: 10px; text-decoration: none;">üì•</a>
                        </div>
                    </div>
                `;
            }
            
            // Audio files
            if (['mp3', 'wav', 'ogg', 'm4a'].includes(extension)) {
                return `
                    <div class="message-attachment">
                        <audio controls>
                            <source src="${fileUrl}" type="audio/${extension}">
                            Your browser doesn't support audio playback.
                        </audio>
                        <div style="font-size: 0.85em; margin-top: 5px; opacity: 0.8;">
                            ${fileName} (${sizeText})
                        </div>
                    </div>
                `;
            }
            
            // Document/Other files - make all files downloadable
            const fileIcon = getFileIcon(extension);
            return `
                <div class="message-attachment">
                    <a href="${fileUrl}?original_name=${encodeURIComponent(fileName)}" class="file-download" download="${fileName}" target="_blank">
                        <span style="font-size: 1.5em;">${fileIcon}</span>
                        <div>
                            <div style="font-weight: 600;">üì• ${fileName}</div>
                            <div style="font-size: 0.85em; opacity: 0.7;">${sizeText} ‚Ä¢ Click to download</div>
                        </div>
                    </a>
                </div>
            `;
        }

        function getFileIcon(extension) {
            const icons = {
                'pdf': 'üìÑ',
                'doc': 'üìù',
                'docx': 'üìù',
                'txt': 'üìù',
                'zip': 'üóúÔ∏è',
                'rar': 'üóúÔ∏è',
                'xls': 'üìä',
                'xlsx': 'üìä'
            };
            return icons[extension] || 'üìé';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Check file size (50MB limit)
            if (file.size > 50 * 1024 * 1024) {
                showError('File size must be less than 50MB');
                event.target.value = '';
                return;
            }
            
            selectedFile = file;
            document.getElementById('file-preview-name').textContent = `üìé ${file.name} (${formatFileSize(file.size)})`;
            document.getElementById('file-preview').classList.add('show');
        }

        function removeFile() {
            selectedFile = null;
            document.getElementById('file-input').value = '';
            document.getElementById('file-preview').classList.remove('show');
        }

        async function uploadFile() {
            if (!selectedFile) return null;
            
            const formData = new FormData();
            formData.append('file', selectedFile);
            
            try {
                const response = await fetch(`${API_URL}/upload`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data;
                } else {
                    showError('Failed to upload file');
                    return null;
                }
            } catch (error) {
                showError('Failed to upload file');
                return null;
            }
        }

        async function markMessagesAsRead() {
            if (!currentUser || currentUser.role === 'administrator') return;
            
            try {
                await fetch(`${API_URL}/messages/mark-read`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
            } catch (error) {
                // Silently fail, not critical
                console.error('Failed to mark messages as read:', error);
            }
        }

        // Auto-resize textarea with max 5 lines
        function autoResizeTextarea(textarea) {
            // Reset height to get accurate scrollHeight
            textarea.style.height = 'auto';
            
            // Calculate height based on content
            const lineHeight = parseInt(getComputedStyle(textarea).lineHeight);
            const maxLines = 5;
            const maxHeight = lineHeight * maxLines;
            
            if (textarea.scrollHeight <= maxHeight) {
                textarea.style.height = textarea.scrollHeight + 'px';
                textarea.style.overflowY = 'hidden';
            } else {
                textarea.style.height = maxHeight + 'px';
                textarea.style.overflowY = 'auto';
            }
        }

        async function sendMessage() {
            const input = document.getElementById('message-input');
            const message = input.value.trim();

            if (!message && !selectedFile) {
                showError('Please enter a message or attach a file');
                return;
            }

            try {
                // Upload file first if selected
                let fileData = null;
                if (selectedFile) {
                    fileData = await uploadFile();
                    if (!fileData) return; // Upload failed
                }

                const body = { 
                    message: message || ''
                };
                
                if (fileData) {
                    body.file_url = fileData.file_url;
                    body.file_name = fileData.original_filename;
                    body.file_size = fileData.file_size;
                }
                
                if (replyToId) {
                    body.reply_to = replyToId;
                }
                
                if (currentUser.role === 'administrator' && selectedUserId) {
                    body.user_id = selectedUserId;
                }

                const response = await fetch(`${API_URL}/messages/send`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(body)
                });

                if (response.ok) {
                    input.value = '';
                    input.style.height = 'auto'; // Reset textarea height
                    removeFile();
                    cancelReply();
                    if (currentUser.role === 'administrator' && selectedUserId) {
                        await loadUserMessages(selectedUserId);
                        await loadUserList(); // Refresh unread counts IMMEDIATELY
                    } else {
                        loadMessages();
                    }
                } else {
                    showError('Failed to send message');
                }
            } catch (error) {
                showError('Failed to send message');
            }
        }

        function replyToMessage(messageId, messageText) {
            replyToId = messageId;
            const replyBar = document.getElementById('reply-bar');
            const replyPreview = document.getElementById('reply-preview');
            replyBar.classList.add('show');
            replyPreview.textContent = messageText.substring(0, 100) + (messageText.length > 100 ? '...' : '');
            document.getElementById('message-input').focus();
        }

        function cancelReply() {
            replyToId = null;
            const replyBar = document.getElementById('reply-bar');
            replyBar.classList.remove('show');
        }

        async function deleteMessage(messageId) {
            if (!confirm('Delete this message?')) return;
            
            try {
                const response = await fetch(`${API_URL}/messages/${messageId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    showSuccess('Message deleted');
                    // Refresh messages
                    if (currentUser.role === 'administrator' && selectedUserId) {
                        await loadUserMessages(selectedUserId);
                    } else {
                        loadMessages();
                    }
                } else {
                    showError('Failed to delete message');
                }
            } catch (error) {
                showError('Failed to delete message');
            }
        }

        function logout() {
            console.log('[Logout] Starting logout process...');
            
            // Clear token from localStorage FIRST
            localStorage.removeItem('chatapp_token');
            
            // Clear global token variable
            token = null;
            currentUser = null;
            selectedUserId = null;
            
            // Clear all intervals
            if (messageInterval) {
                clearInterval(messageInterval);
                messageInterval = null;
            }
            if (adminMessageInterval) {
                clearInterval(adminMessageInterval);
                adminMessageInterval = null;
            }
            if (signalPollInterval) {
                clearInterval(signalPollInterval);
                signalPollInterval = null;
            }
            
            // Stop heartbeat and cleanup calls
            stopHeartbeat();
            if (currentCallId) {
                hangupCall('Logged out');
            }
            
            console.log('[Logout] Token cleared:', localStorage.getItem('chatapp_token'));
            console.log('[Logout] All intervals cleared');
            
            // Show login screen
            document.getElementById('auth-section').style.display = 'block';
            document.getElementById('chat-section').style.display = 'none';
            showLogin();
            
            // Clear any stored credentials (in case they exist)
            localStorage.removeItem('chatapp_saved_username');
            localStorage.removeItem('chatapp_saved_password');
            localStorage.removeItem('chatapp_remember_me');
        }

        // ========== Settings & Password Change ==========

        function showSettings() {
            document.getElementById('settings-modal').classList.add('show');
            // Populate hidden username field for accessibility
            if (currentUser) {
                document.getElementById('change-password-username').value = currentUser.username;
            }
        }

        function saveAdminNameForUser(userId, name) {
            const trimmedName = name.trim() || 'Ken';
            localStorage.setItem(`admin_name_for_user_${userId}`, trimmedName);
            showSuccess(`Admin name for this user saved as: ${trimmedName}`);
        }

        function closeSettings() {
            document.getElementById('settings-modal').classList.remove('show');
            // Hide any error/success messages
            document.getElementById('settings-error-message').style.display = 'none';
            document.getElementById('settings-success-message').style.display = 'none';
            // Reset form
            const form = document.getElementById('change-password-form');
            if (form) form.reset();
            document.getElementById('current-password').value = '';
            document.getElementById('new-password').value = '';
            document.getElementById('confirm-password').value = '';
        }

        function togglePasswordVisibility(inputId, button) {
            const input = document.getElementById(inputId);
            if (input.type === 'password') {
                input.type = 'text';
                button.textContent = 'Hide';
            } else {
                input.type = 'password';
                button.textContent = 'Show';
            }
        }

        async function changePassword() {
            console.log('üîê [Password Change] Function called');
            
            // Hide any previous messages
            document.getElementById('settings-error-message').style.display = 'none';
            document.getElementById('settings-success-message').style.display = 'none';
            
            const currentPassword = document.getElementById('current-password').value;
            const newPassword = document.getElementById('new-password').value;
            const confirmPassword = document.getElementById('confirm-password').value;

            console.log('üîê [Password Change] Form values retrieved:', {
                currentPasswordLength: currentPassword.length,
                newPasswordLength: newPassword.length,
                confirmPasswordLength: confirmPassword.length
            });

            if (!currentPassword || !newPassword || !confirmPassword) {
                console.log('‚ùå [Password Change] Validation failed: Empty fields');
                showError('Please fill all password fields');
                return;
            }

            if (newPassword !== confirmPassword) {
                console.log('‚ùå [Password Change] Validation failed: Passwords do not match');
                showError('New passwords do not match');
                document.getElementById('new-password').value = '';
                document.getElementById('confirm-password').value = '';
                document.getElementById('new-password').focus();
                return;
            }

            if (newPassword.length < 6) {
                console.log('‚ùå [Password Change] Validation failed: Password too short');
                showError('New password must be at least 6 characters (current: ' + newPassword.length + ' characters)');
                document.getElementById('new-password').value = '';
                document.getElementById('confirm-password').value = '';
                document.getElementById('new-password').focus();
                return;
            }

            console.log('‚úÖ [Password Change] Validation passed, sending request to server');

            try {
                const requestBody = {
                    currentPassword: currentPassword,
                    newPassword: newPassword
                };
                
                console.log('üîê [Password Change] Request details:', {
                    url: `${API_URL}/auth/change-password`,
                    method: 'POST',
                    hasToken: !!token,
                    tokenLength: token ? token.length : 0
                });

                const response = await fetch(`${API_URL}/auth/change-password`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('üîê [Password Change] Response received:', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok
                });

                const data = await response.json();
                console.log('üîê [Password Change] Response data:', data);

                if (response.ok) {
                    console.log('‚úÖ [Password Change] SUCCESS!');
                    showSuccess('Password changed successfully!');
                    // Clear all password fields
                    document.getElementById('current-password').value = '';
                    document.getElementById('new-password').value = '';
                    document.getElementById('confirm-password').value = '';
                    closeSettings();
                } else {
                    console.log('‚ùå [Password Change] Server returned error:', data.error);
                    showError(data.error || 'Failed to change password');
                    // Clear current password if it's wrong
                    if (data.error && data.error.includes('current password')) {
                        document.getElementById('current-password').value = '';
                        document.getElementById('current-password').focus();
                    }
                }
            } catch (error) {
                console.error('‚ùå [Password Change] Exception caught:', error);
                showError('Failed to change password: ' + error.message);
            }
        }

        // ========== Admin Tab Switching with Width Memory ==========

        // Store width preferences for each tab
        let tabWidths = {
            conversations: localStorage.getItem('admin_width_conversations') || '450px',
            users: localStorage.getItem('admin_width_users') || '450px'
        };
        let currentAdminTab = 'conversations';

        function showAdminTab(tab) {
            // Save current tab width before switching
            const adminPanel = document.getElementById('admin-panel');
            if (adminPanel.style.width) {
                tabWidths[currentAdminTab] = adminPanel.style.width;
                localStorage.setItem(`admin_width_${currentAdminTab}`, tabWidths[currentAdminTab]);
            }
            
            // Update current tab
            currentAdminTab = tab;
            
            // Update tab buttons
            document.querySelectorAll('.admin-tab').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Restore width for new tab
            adminPanel.style.width = tabWidths[tab];
            
            // Show/hide tab content
            if (tab === 'conversations') {
                document.getElementById('admin-conversations-tab').style.display = 'block';
                document.getElementById('admin-users-tab').style.display = 'none';
                // Show messages container and input section
                document.getElementById('messages-container').style.display = 'block';
                document.getElementById('reply-bar').style.display = 'none';
                // Refresh conversation list
                loadUserList();
                // If a user was selected, reload their messages
                if (selectedUserId) {
                    loadUserMessages(selectedUserId);
                    document.getElementById('message-input-section').style.display = 'flex';
                } else {
                    document.getElementById('message-input-section').style.display = 'none';
                }
            } else {
                document.getElementById('admin-conversations-tab').style.display = 'none';
                document.getElementById('admin-users-tab').style.display = 'block';
                // Hide messages container and input section in Users tab
                document.getElementById('messages-container').style.display = 'none';
                document.getElementById('message-input-section').style.display = 'none';
                
                loadAllUsers();
            }
        }

        // ========== Resizable Admin Panel ==========

        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        document.addEventListener('DOMContentLoaded', () => {
            // Setup video tap/click handlers
            const localVideo = document.getElementById('local-video');
            const remoteVideo = document.getElementById('remote-video');
            
            // Track tap timing for distinguishing single vs double tap
            let lastTapTime = 0;
            let tapTimeout = null;
            const doubleTapDelay = 300; // milliseconds
            
            function setupVideoHandlers(videoElement) {
                if (!videoElement) return;
                
                debugLog('VIDEO', `Setting up video handlers for: ${videoElement.id}`);
                debugLog('VIDEO', `Device type: ${deviceInfo.isMobile ? 'MOBILE' : 'DESKTOP'}`);
                
                let touchHandled = false; // Flag to prevent click after touch
                
                const handleTouch = (e) => {
                    // Mobile: Use touch event with better detection
                    // CRITICAL: Prevent default to stop click from firing
                    e.preventDefault();
                    e.stopPropagation();
                    
                    touchHandled = true;  // Mark that touch was handled
                    
                    const currentTime = new Date().getTime();
                    const tapGap = currentTime - lastTapTime;
                    
                    debugLog('VIDEO', `Touch on ${videoElement.id}, gap: ${tapGap}ms`);
                    
                    if (tapGap < doubleTapDelay && tapGap > 0) {
                        // Double tap detected
                        clearTimeout(tapTimeout);
                        debugLog('VIDEO', 'Double-tap detected - fullscreen');
                        toggleFullscreen(videoElement);
                        lastTapTime = 0;
                    } else {
                        // Single tap - wait to confirm
                        lastTapTime = currentTime;
                        tapTimeout = setTimeout(() => {
                            debugLog('VIDEO', 'Single tap confirmed - swap videos');
                            swapVideos();
                            touchHandled = false;  // Reset immediately after action
                        }, doubleTapDelay);
                    }
                };
                
                const handleClick = (e) => {
                    // Desktop: Use click event (or mobile fallback if no touch)
                    
                    // On mobile, ignore click if touch was already handled
                    if (touchHandled) {
                        debugLog('VIDEO', 'Click ignored - touch already handled');
                        return;
                    }
                    
                    const currentTime = new Date().getTime();
                    const tapGap = currentTime - lastTapTime;
                    
                    debugLog('VIDEO', `Click on ${videoElement.id}, gap: ${tapGap}ms`);
                    
                    if (tapGap < doubleTapDelay && tapGap > 0) {
                        // Double click detected
                        e.preventDefault();
                        clearTimeout(tapTimeout);
                        debugLog('VIDEO', 'Double-click detected - fullscreen');
                        toggleFullscreen(videoElement);
                        lastTapTime = 0;
                    } else {
                        // Single click - wait to confirm
                        lastTapTime = currentTime;
                        tapTimeout = setTimeout(() => {
                            debugLog('VIDEO', 'Single click confirmed - swap videos');
                            swapVideos();
                        }, doubleTapDelay);
                    }
                };
                
                // Add touch handler if mobile (always add for mobile devices)
                if (deviceInfo.isMobile) {
                    debugLog('VIDEO', 'Adding touchstart handler for mobile');
                    videoElement.addEventListener('touchstart', handleTouch, { passive: false });
                }
                
                // Always add click handler (but it checks touchHandled flag on mobile)
                debugLog('VIDEO', 'Adding click handler');
                videoElement.addEventListener('click', handleClick);
            }
            
            setupVideoHandlers(localVideo);
            setupVideoHandlers(remoteVideo);
            
            // Setup resize handle
            const resizeHandle = document.getElementById('resize-handle');
            const adminPanel = document.getElementById('admin-panel');
            
            if (resizeHandle && adminPanel) {
                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startWidth = adminPanel.offsetWidth;
                    resizeHandle.classList.add('dragging');
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaX = e.clientX - startX;
                    const newWidth = startWidth + deltaX;
                    
                    if (newWidth >= 300 && newWidth <= 800) {
                        adminPanel.style.width = newWidth + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        resizeHandle.classList.remove('dragging');
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        
                        // Save the new width for current tab
                        tabWidths[currentAdminTab] = adminPanel.style.width;
                        localStorage.setItem(`admin_width_${currentAdminTab}`, tabWidths[currentAdminTab]);
                    }
                });
            }
        });

        // ========== F5 Key: Refresh Data Instead of Page Reload ==========
        
        document.addEventListener('keydown', (e) => {
            // Check if F5 key is pressed (key code 116 or key name 'F5')
            if (e.key === 'F5' || e.keyCode === 116) {
                e.preventDefault(); // Prevent page reload
                
                // Refresh data based on current screen
                const authSection = document.getElementById('auth-section');
                const chatSection = document.getElementById('chat-section');
                
                if (chatSection && chatSection.style.display !== 'none') {
                    // User is logged in - refresh chat data
                    console.log('üîÑ F5: Refreshing chat data...');
                    
                    // Refresh messages
                    if (typeof loadMessages === 'function') {
                        loadMessages();
                    }
                    
                    // Refresh user list if admin
                    if (currentUser && currentUser.role === 'administrator') {
                        if (typeof loadUserList === 'function') {
                            loadUserList();
                        }
                        if (typeof loadAllUsers === 'function' && currentAdminTab === 'users') {
                            loadAllUsers(showDeletedUsers);
                        }
                    }
                    
                    // Show feedback
                    showSuccess('Data refreshed');
                } else if (authSection && authSection.style.display !== 'none') {
                    // User is on login screen - just prevent reload
                    console.log('üîÑ F5: On login screen, prevented reload');
                }
            }
        });

        // ========== Admin User Management ==========

        async function loadAllUsers(includeDeleted) {
            try {
                const response = await fetch(`${API_URL}/admin/users?include_deleted=${includeDeleted}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                const users = await response.json();
                const usersList = document.getElementById('all-users-list');
                
                // Update tab label with count
                const activeUsers = users.filter(u => !u.is_deleted);
                document.getElementById('users-tab-label').textContent = `${activeUsers.length} Users`;
                
                if (users.length === 0) {
                    usersList.innerHTML = '<p style="text-align: center; color: #666;">No users found</p>';
                    return;
                }

                usersList.innerHTML = users.map(user => {
                    const isDeleted = user.is_deleted;
                    const isSelf = user.id === currentUser.id;
                    const savedName = localStorage.getItem(`admin_name_for_user_${user.id}`) || 'Ken';
                    
                    return `
                        <div class="user-item ${isDeleted ? 'deleted' : ''}" style="cursor: default;">
                            <div class="user-item-info" style="flex: 1;">
                                <strong>${user.username}</strong> ${isSelf ? '(You)' : ''}
                                <div style="font-size: 0.85em; color: #666; margin-top: 4px;">
                                    ${user.email}
                                </div>
                                ${!isSelf && !isDeleted ? `
                                    <div style="margin-top: 8px; display: flex; gap: 8px; align-items: center;">
                                        <label style="font-size: 0.85em; color: #667eea; font-weight: 600;">Admin Name for ${user.username}:</label>
                                        <input type="text" id="admin-name-${user.id}" value="${savedName}" 
                                               placeholder="Ken" 
                                               style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; width: 120px;"
                                               onchange="saveAdminNameForUser(${user.id}, this.value)">
                                    </div>
                                ` : ''}
                            </div>
                            ${!isSelf ? `
                                <div class="user-item-actions" onclick="event.stopPropagation()">
                                    ${!isDeleted ? `
                                        <button class="btn-small btn-delete" onclick="deleteUser(${user.id}, '${user.username}')">
                                            Delete
                                        </button>
                                    ` : `
                                        <button class="btn-small btn-restore" onclick="restoreUser(${user.id}, '${user.username}')">
                                            Restore
                                        </button>
                                        <button class="btn-small btn-permanent" onclick="permanentDeleteUser(${user.id}, '${user.username}')">
                                            Delete Forever
                                        </button>
                                    `}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            } catch (error) {
                showError('Failed to load users');
            }
        }

        function toggleShowDeleted() {
            const checkbox = document.getElementById('show-deleted-toggle');
            loadAllUsers(checkbox.checked);
        }

        async function bulkDeleteUsers() {
            showConfirmModal(
                'Remove All Deleted Users',
                'This will PERMANENTLY delete all soft-deleted users and their associated data (conversations, messages, etc.). This action CANNOT be undone!',
                async () => {
                    try {
                        const response = await fetch(`${API_URL}/admin/users/bulk-delete-deleted`, {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        const result = await response.json();

                        if (response.ok) {
                            showSuccess(`Removed ${result.deleted_count || 0} deleted users permanently`);
                            // Refresh user list
                            const checkbox = document.getElementById('show-deleted-toggle');
                            loadAllUsers(checkbox.checked);
                        } else {
                            showError(result.error || 'Failed to bulk delete users');
                        }
                    } catch (error) {
                        showError('Failed to bulk delete users');
                    }
                }
            );
        }

        let confirmCallback = null;

        function showConfirmModal(title, message, callback) {
            document.getElementById('confirm-title').textContent = title;
            document.getElementById('confirm-message').textContent = message;
            confirmCallback = callback;
            document.getElementById('confirm-modal').classList.add('show');
        }

        function closeConfirmModal() {
            document.getElementById('confirm-modal').classList.remove('show');
            confirmCallback = null;
        }

        function confirmAction() {
            if (confirmCallback) {
                confirmCallback();
            }
            closeConfirmModal();
        }

        async function deleteUser(userId, username) {
            showConfirmModal(
                'Delete User',
                `Are you sure you want to delete ${username}? This can be undone later.`,
                async () => {
                    try {
                        const response = await fetch(`${API_URL}/admin/users/${userId}/delete`, {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (response.ok) {
                            showSuccess(`User ${username} deleted successfully`);
                            loadAllUsers(true); // Reload with deleted users
                        } else {
                            const data = await response.json();
                            showError(data.error || 'Failed to delete user');
                        }
                    } catch (error) {
                        showError('Failed to delete user');
                    }
                }
            );
        }

        async function restoreUser(userId, username) {
            try {
                const response = await fetch(`${API_URL}/admin/users/${userId}/restore`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    showSuccess(`User ${username} restored successfully`);
                    loadAllUsers(true); // Reload
                } else {
                    const data = await response.json();
                    showError(data.error || 'Failed to restore user');
                }
            } catch (error) {
                showError('Failed to restore user');
            }
        }

        async function permanentDeleteUser(userId, username) {
            showConfirmModal(
                '‚ö†Ô∏è Permanent Delete',
                `Are you sure you want to PERMANENTLY delete ${username}? This CANNOT be undone! All their messages will be deleted.`,
                async () => {
                    try {
                        const response = await fetch(`${API_URL}/admin/users/${userId}/permanent-delete`, {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (response.ok) {
                            showSuccess(`User ${username} permanently deleted`);
                            loadAllUsers(true); // Reload
                        } else {
                            const data = await response.json();
                            showError(data.error || 'Failed to delete user');
                        }
                    } catch (error) {
                        showError('Failed to delete user');
                    }
                }
            );
        }

        // ============= VOICE CALL FUNCTIONS =============
        // Embedded inline to avoid 404 errors
        
        // ========== Heartbeat & Status Management ==========
        
        function startHeartbeat() {
            console.log('üì° Starting heartbeat...');
            sendHeartbeat();
            heartbeatInterval = setInterval(sendHeartbeat, 10000);
            updateMyStatus('online');
        }

        async function sendHeartbeat() {
            try {
                await fetch(`${API_URL}/status/heartbeat`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
            } catch (error) {
                console.error('Heartbeat failed:', error);
            }
        }

        async function updateMyStatus(status, currentCallWith = null) {
            try {
                await fetch(`${API_URL}/status/update`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        status: status,
                        current_call_with: currentCallWith
                    })
                });
                console.log(`üìä Status updated to: ${status}`);
            } catch (error) {
                console.error('Status update failed:', error);
            }
        }

        async function getUserStatus(userId) {
            try {
                const response = await fetch(`${API_URL}/status/user/${userId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                return await response.json();
            } catch (error) {
                console.error('Failed to get user status:', error);
                return { status: 'offline' };
            }
        }

        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
            updateMyStatus('offline');
        }

        async function updateStatusIndicator(userId) {
            const status = await getUserStatus(userId);
            const indicator = document.getElementById('admin-status-indicator');
            
            if (!indicator) return;
            
            let statusClass, statusText, dotClass;
            
            switch (status.status) {
                case 'online':
                    statusClass = 'status-online';
                    statusText = 'Online';
                    dotClass = 'dot-online';
                    break;
                case 'in_call':
                    statusClass = 'status-in-call';
                    statusText = 'Not Available';
                    dotClass = 'dot-in-call';
                    break;
                default:
                    statusClass = 'status-offline';
                    statusText = 'Offline';
                    dotClass = 'dot-offline';
            }
            
            indicator.innerHTML = `
                <span class="status-indicator ${statusClass}">
                    <span class="status-dot ${dotClass}"></span>
                    ${statusText}
                </span>
            `;
            indicator.style.display = 'block';
        }

        // ========== Call Initiation ==========
        
        // For admin to call users
        async function callUser(userId, username) {
            debugLog('CALL-INIT', `========== ADMIN CALLING USER ==========`);
            debugLog('CALL-INIT', `Target: ${username} (ID: ${userId})`);
            debugLog('CALL-INIT', `Device: ${deviceInfo.isMobile ? 'MOBILE' : 'PC'} | ${deviceInfo.os} ${deviceInfo.browser}`);
            
            try {
                // Check if WebRTC is supported
                debugLog('CALL-INIT', 'Checking WebRTC support...');
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    debugLog('CALL-INIT', '‚ùå WebRTC NOT supported on this device');
                    showError('Voice calls are not supported in this browser');
                    return;
                }
                debugLog('CALL-INIT', '‚úÖ WebRTC supported');
                
                // Request microphone permission
                debugLog('CALL-INIT', 'Requesting microphone permission...');
                try {
                    const startTime = Date.now();
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const duration = Date.now() - startTime;
                    debugLog('CALL-INIT', `‚úÖ Microphone granted in ${duration}ms`);
                    debugLog('CALL-INIT', `Audio tracks: ${localStream.getAudioTracks().length}`, localStream.getAudioTracks()[0]?.getSettings());
                } catch (error) {
                    debugLog('CALL-INIT', '‚ùå Microphone permission DENIED', error);
                    showError('Microphone permission denied. Please enable microphone access.');
                    console.error('Microphone error:', error);
                    return;
                }
                
                // Initiate call via API
                debugLog('CALL-INIT', 'Calling backend API /call/initiate...');
                const apiStartTime = Date.now();
                const response = await fetch(`${API_URL}/call/initiate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ callee_id: userId })
                });
                
                const data = await response.json();
                const apiDuration = Date.now() - apiStartTime;
                debugLog('CALL-INIT', `API response in ${apiDuration}ms:`, data);
                
                if (!data.success) {
                    // User is offline
                    debugLog('CALL-INIT', `‚ùå Call initiation failed: ${data.reason}`);
                    if (localStream) {
                        localStream.getTracks().forEach(track => track.stop());
                        localStream = null;
                        debugLog('CALL-INIT', 'Local stream cleaned up');
                    }
                    
                    if (data.reason === 'offline') {
                        showError(`${username} is offline.`);
                    } else {
                        showError(`Unable to call ${username}.`);
                    }
                    
                    return;
                }
                
                // Call initiated successfully
                currentCallId = data.call_id;
                currentCallState = 'calling';
                remoteUserId = userId; // Track who we're calling
                debugLog('CALL-INIT', `‚úÖ Call initiated! Call ID: ${currentCallId}`);
                debugLog('CALL-INIT', `State: ${currentCallState}`);
                debugLog('CALL-INIT', `remoteUserId set to: ${remoteUserId}`);
                
                // Show calling UI
                debugLog('CALL-INIT', 'Showing calling UI...');
                document.getElementById('active-call-name').textContent = username;
                document.getElementById('active-call-status').textContent = 'Calling...';
                document.getElementById('call-timer').textContent = '00:00';
                document.getElementById('active-call-modal').classList.add('show');
                debugLog('CALL-INIT', '‚úÖ Calling UI displayed');
                
                // Set up WebRTC with user (not admin)
                debugLog('CALL-INIT', `Setting up peer connection with userId: ${userId}...`);
                await setupPeerConnection(userId);
                
                // Create and send offer (include video constraint even if not enabled yet)
                debugLog('CALL-INIT', 'Creating WebRTC offer...');
                const offerStartTime = Date.now();
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                await peerConnection.setLocalDescription(offer);
                const offerDuration = Date.now() - offerStartTime;
                debugLog('CALL-INIT', `‚úÖ Offer created in ${offerDuration}ms`);
                debugLog('CALL-INIT', `SDP type: ${offer.type}, length: ${offer.sdp.length}`);
                
                // Send offer via signaling
                debugLog('CALL-INIT', `Sending offer to userId: ${userId}...`);
                await sendSignal(userId, {
                    type: 'offer',
                    sdp: offer.sdp,
                    call_id: currentCallId
                });
                debugLog('CALL-INIT', '‚úÖ Offer sent via signaling');
                
                // Start polling for signals
                debugLog('CALL-INIT', 'Starting signal polling...');
                startSignalPolling();
                
                // Set timeout and store it
                callTimeoutTimer = setTimeout(() => {
                    if (currentCallState === 'calling') {
                        debugLog('CALL-INIT', '‚è∞ Call timeout - no answer after 30s');
                        hangupCall('No answer');
                    }
                }, 30000);
                debugLog('CALL-INIT', '‚úÖ 30s timeout set');
                debugLog('CALL-INIT', '========================================');
                
            } catch (error) {
                console.error('Call initiation failed:', error);
                showError('Failed to initiate call');
                
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
            }
        }
        
        async function initiateCall() {
            debugLog('CALL-INIT', '========== USER CALLING ADMIN ==========');
            debugLog('CALL-INIT', `Device: ${deviceInfo.isMobile ? 'MOBILE' : 'PC'} | ${deviceInfo.os} ${deviceInfo.browser}`);
            
            const callBtn = document.getElementById('call-admin-btn');
            if (callBtn) {
                callBtn.disabled = true;
                debugLog('CALL-INIT', 'Call button disabled');
            }
            
            try {
                // Check if WebRTC is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    showError('Voice calls are not supported in this browser');
                    return;
                }
                
                // Get admin ID
                debugLog('CALL-INIT', `Admin ID: ${adminId}`);
                if (!adminId) {
                    debugLog('CALL-INIT', '‚ùå Admin ID not found!');
                    showError('Admin ID not found');
                    return;
                }
                
                // Request microphone permission
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    console.log('üé§ Microphone access granted');
                } catch (error) {
                    showError('Microphone permission denied. Please enable microphone access.');
                    console.error('Microphone error:', error);
                    if (callBtn) callBtn.disabled = false;
                    return;
                }
                
                // Initiate call via API
                const response = await fetch(`${API_URL}/call/initiate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ callee_id: adminId })
                });
                
                const data = await response.json();
                
                if (!data.success) {
                    // Admin is busy or offline
                    if (localStream) {
                        localStream.getTracks().forEach(track => track.stop());
                        localStream = null;
                    }
                    
                    if (data.reason === 'busy') {
                        showError('Admin is currently unavailable. Your call has been recorded.');
                    } else if (data.reason === 'offline') {
                        showError('Admin is offline. Your call has been recorded.');
                    }
                    
                    if (callBtn) callBtn.disabled = false;
                    return;
                }
                
                // Call initiated successfully
                currentCallId = data.call_id;
                currentCallState = 'calling';
                remoteUserId = adminId; // Track who we're calling
                debugLog('CALL-INIT', `remoteUserId set to: ${remoteUserId}`);
                
                // Show calling UI
                showCallingUI();
                
                // Set up WebRTC
                await setupPeerConnection(adminId);
                
                // Create and send offer (include video constraint even if not enabled yet)
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                await peerConnection.setLocalDescription(offer);
                
                // Send offer via signaling
                await sendSignal(adminId, {
                    type: 'offer',
                    sdp: offer.sdp,
                    call_id: currentCallId
                });
                
                // Start polling for signals
                startSignalPolling();
                
                // Set timeout and store it
                callTimeoutTimer = setTimeout(() => {
                    if (currentCallState === 'calling') {
                        console.log('‚è∞ Call timeout - no answer');
                        hangupCall('No answer');
                    }
                }, 30000);
                
            } catch (error) {
                console.error('Call initiation failed:', error);
                showError('Failed to initiate call');
                if (callBtn) callBtn.disabled = false;
                
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
            }
        }

        // ========== WebRTC Setup (Unified) ==========
        
        /**
         * Unified peer connection setup for ALL call scenarios:
         * - Admin calling user
         * - User calling admin
         * - Phone to phone
         * - PC to PC
         * - Any combination!
         * 
         * @param {number} remoteUserId - ID of the user we're calling/answering
         */
        async function setupPeerConnection(remoteUserId) {
            debugLog('WEBRTC', '========== SETUP PEER CONNECTION ==========');
            debugLog('WEBRTC', `Remote User ID: ${remoteUserId}`);
            debugLog('WEBRTC', `Device: ${deviceInfo.isMobile ? 'MOBILE' : 'PC'} | ${deviceInfo.os} ${deviceInfo.browser}`);
            
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' }
                ]
            };
            debugLog('WEBRTC', `ICE servers configured: ${configuration.iceServers.length}`);
            
            peerConnection = new RTCPeerConnection(configuration);
            debugLog('WEBRTC', '‚úÖ RTCPeerConnection created');
            
            // Add local stream tracks
            if (localStream) {
                const tracks = localStream.getTracks();
                debugLog('WEBRTC', `Adding ${tracks.length} local tracks...`);
                tracks.forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    debugLog('WEBRTC', `‚ûï Added ${track.kind} track (enabled: ${track.enabled}, muted: ${track.muted})`);
                });
            } else {
                debugLog('WEBRTC', '‚ö†Ô∏è WARNING: No local stream when setting up peer connection');
            }
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                debugLog('WEBRTC', `üì• Received remote ${event.track.kind} track`);
                debugLog('WEBRTC', `Track state: readyState=${event.track.readyState}, enabled=${event.track.enabled}`);
                remoteStream = event.streams[0];
                debugLog('WEBRTC', `Remote stream ID: ${remoteStream.id}, tracks: ${remoteStream.getTracks().length}`);
                
                // Always set audio element for sound
                const remoteAudio = document.getElementById('remote-audio');
                if (remoteAudio && remoteStream) {
                    remoteAudio.srcObject = remoteStream;
                    debugLog('WEBRTC', 'üîä Audio stream set to remote-audio element');
                } else {
                    debugLog('WEBRTC', '‚ö†Ô∏è Remote audio element not found or no stream');
                }
                
                // If video track, also set video element
                if (event.track.kind === 'video') {
                    const remoteVideo = document.getElementById('remote-video');
                    if (remoteVideo) {
                        remoteVideo.srcObject = remoteStream;
                        debugLog('WEBRTC', 'üìπ Video stream set to remote-video element');
                        
                        // Force play the video element (important for some browsers)
                        remoteVideo.play().then(() => {
                            debugLog('WEBRTC', '‚úÖ Remote video playing');
                        }).catch(e => {
                            debugLog('WEBRTC', `‚ö†Ô∏è Video autoplay failed: ${e.message}`);
                        });
                        
                        // Show video container
                        document.getElementById('video-container').style.display = 'block';
                        document.getElementById('audio-view').style.display = 'none';
                        debugLog('WEBRTC', 'Video container shown, audio view hidden');
                    } else {
                        debugLog('WEBRTC', '‚ö†Ô∏è Remote video element not found');
                    }
                }
            };
            
            // Handle ICE candidates - Works for both directions
            let iceCount = 0;
            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    iceCount++;
                    debugLog('WEBRTC', `üßä ICE candidate #${iceCount} for user ${remoteUserId}`);
                    debugLog('WEBRTC', `Type: ${event.candidate.type}, Protocol: ${event.candidate.protocol}, Address: ${event.candidate.address || 'N/A'}`);
                    await sendSignal(remoteUserId, {
                        type: 'ice',
                        candidate: event.candidate.toJSON(),
                        call_id: currentCallId
                    });
                } else {
                    debugLog('WEBRTC', `‚úÖ ICE gathering complete. Total candidates: ${iceCount}`);
                }
            };
            
            // Handle ICE connection state changes
            peerConnection.oniceconnectionstatechange = () => {
                debugLog('WEBRTC', `üßä ICE connection state changed: ${peerConnection.iceConnectionState}`);
                debugLog('WEBRTC', `ICE gathering state: ${peerConnection.iceGatheringState}`);
                
                if (peerConnection.iceConnectionState === 'failed') {
                    debugLog('WEBRTC', '‚ùå ICE connection FAILED - attempting restart');
                    peerConnection.restartIce();
                } else if (peerConnection.iceConnectionState === 'disconnected') {
                    debugLog('WEBRTC', '‚ö†Ô∏è ICE connection DISCONNECTED - waiting for reconnection');
                } else if (peerConnection.iceConnectionState === 'connected') {
                    debugLog('WEBRTC', '‚úÖ ICE connection CONNECTED');
                } else if (peerConnection.iceConnectionState === 'checking') {
                    debugLog('WEBRTC', 'üîç ICE connection CHECKING');
                }
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                debugLog('WEBRTC', `üîå Connection state changed: ${peerConnection.connectionState}`);
                debugLog('WEBRTC', `Signaling state: ${peerConnection.signalingState}`);
                
                if (peerConnection.connectionState === 'connected') {
                    debugLog('WEBRTC', `‚úÖ CALL CONNECTED with user: ${remoteUserId}`);
                    debugLog('WEBRTC', `Device: ${deviceInfo.isMobile ? 'MOBILE' : 'PC'}`);
                    currentCallState = 'connected';
                    
                    // Clear timeout since call connected
                    if (callTimeoutTimer) {
                        clearTimeout(callTimeoutTimer);
                        callTimeoutTimer = null;
                        console.log('‚è∞ Call timeout cleared - connected');
                    }
                    
                    // Update UI to show connected
                    const statusEl = document.getElementById('active-call-status');
                    if (statusEl) {
                        statusEl.textContent = 'Connected';
                        statusEl.style.color = ''; // Reset color
                    }
                    
                    // Ensure modal is visible (important for all scenarios)
                    const activeModal = document.getElementById('active-call-modal');
                    if (activeModal && !activeModal.classList.contains('show')) {
                        activeModal.classList.add('show');
                        console.log('üì± Showing active call modal');
                    }
                    
                    // Start call timer if not already running
                    if (!callTimerInterval) {
                        startCallTimer();
                    }
                    
                } else if (peerConnection.connectionState === 'disconnected') {
                    console.log('‚ö†Ô∏è Call disconnected - waiting for reconnection...');
                    // Give it 5 seconds to reconnect
                    setTimeout(() => {
                        if (peerConnection && peerConnection.connectionState === 'disconnected') {
                            console.log('‚ùå Connection still disconnected after 5s');
                            hangupCall('Connection lost');
                        }
                    }, 5000);
                    
                } else if (peerConnection.connectionState === 'failed') {
                    console.log('‚ùå Call connection failed');
                    hangupCall('Connection failed');
                }
            };
            
            console.log('‚úÖ Peer connection setup complete');
        }

        // ========== Signaling ==========
        
        async function sendSignal(targetUserId, signal) {
            try {
                await fetch(`${API_URL}/call/signal`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        target_user_id: targetUserId,
                        signal: signal
                    })
                });
            } catch (error) {
                console.error('Failed to send signal:', error);
            }
        }

        async function pollSignals() {
            if (!token) {
                console.warn('‚ö†Ô∏è No token - signal polling skipped');
                return; // Not logged in
            }
            
            try {
                const response = await fetch(`${API_URL}/call/signals`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (!response.ok) {
                    console.error('‚ùå Signal polling failed:', response.status, response.statusText);
                    return;
                }
                
                const signals = await response.json();
                
                if (signals && signals.length > 0) {
                    console.log(`üì° Received ${signals.length} signal(s) - Current call state:`, currentCallState);
                    console.log('üë§ Current user ID:', currentUser?.id, 'Username:', currentUser?.username);
                    signals.forEach(s => console.log('  - Signal type:', s.signal.type, 'from user:', s.from, 'Type:', typeof s.from));
                }
                
                for (const signalData of signals) {
                    console.log('‚öôÔ∏è Processing signal from user:', signalData.from, 'Type:', signalData.signal.type);
                    await handleSignal(signalData.signal, signalData.from);
                }
            } catch (error) {
                console.error('‚ùå Signal polling error:', error);
                // Continue polling even if there's an error
            }
        }

        async function handleSignal(signal, fromUserId) {
            console.log('üì® Received signal:', signal.type);
            
            // Handle incoming call (offer)
            if (signal.type === 'offer') {
                console.log('üéØ Offer received - Current call state:', currentCallState, 'Has peer:', !!peerConnection);
                
                // Check if this is a renegotiation (already in call)
                if (currentCallState === 'connected' && peerConnection) {
                    console.log('üîÑ RENEGOTIATION DETECTED - Processing video offer');
                    console.log('üìù Call ID:', currentCallId, 'From user:', fromUserId);
                    
                    try {
                        // Accept the new offer
                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                            type: 'offer',
                            sdp: signal.sdp
                        }));
                        console.log('‚úÖ Remote description set');
                        
                        // Create answer (with video support)
                        const answer = await peerConnection.createAnswer({
                            offerToReceiveAudio: true,
                            offerToReceiveVideo: true
                        });
                        await peerConnection.setLocalDescription(answer);
                        console.log('‚úÖ Local description set');
                        
                        // Send answer back
                        await sendSignal(fromUserId, {
                            type: 'answer',
                            sdp: answer.sdp,
                            call_id: currentCallId
                        });
                        
                        console.log('‚úÖ Renegotiation answer sent back to user:', fromUserId);
                    } catch (error) {
                        console.error('‚ùå Renegotiation failed:', error);
                    }
                    return;
                }
                
                // Otherwise, it's a new incoming call
                console.log('üìû New incoming call');
                await handleIncomingCall(signal, fromUserId);
                return;
            }
            
            // For answer and ICE, we need an existing peer connection
            if (!peerConnection) {
                console.log('‚ö†Ô∏è No peer connection for', signal.type);
                return;
            }
            
            if (signal.type === 'answer') {
                console.log('üì• RECEIVED ANSWER from user:', fromUserId, 'Type:', typeof fromUserId);
                console.log('üîó Peer connection exists:', !!peerConnection, 'State:', peerConnection?.connectionState);
                console.log('üìä Current call state:', currentCallState);
                console.log('üìã Call ID:', currentCallId);
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription({
                    type: 'answer',
                    sdp: signal.sdp
                }));
                console.log('‚úÖ Answer received, remote description set, call connecting...');
                currentCallState = 'connecting';
                
                // Clear timeout since other side answered
                if (callTimeoutTimer) {
                    clearTimeout(callTimeoutTimer);
                    callTimeoutTimer = null;
                    console.log('‚è∞ Call timeout cleared - answer received');
                }
                
                // Strong UI feedback that call was answered
                const statusEl = document.getElementById('active-call-status');
                if (statusEl) {
                    statusEl.textContent = '‚úÖ Call Answered - Connecting...';
                    statusEl.style.color = '#4caf50'; // Green color
                    
                    // Reset color after 2 seconds
                    setTimeout(() => {
                        if (statusEl.textContent.includes('Answered')) {
                            statusEl.style.color = '';
                            statusEl.textContent = 'Connecting...';
                        }
                    }, 2000);
                }
                
                // Play a short beep to notify user (mobile-friendly)
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800; // Hz
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    
                    console.log('üîî Answer notification beep played');
                } catch (error) {
                    console.log('‚ö†Ô∏è Could not play notification sound:', error);
                }
                
                // Ensure call modal is visible and bring to front (critical for mobile)
                const activeModal = document.getElementById('active-call-modal');
                if (activeModal) {
                    activeModal.classList.add('show');
                    activeModal.style.zIndex = '10000'; // Ensure it's on top
                    console.log('üì± Call modal ensured visible for answer notification');
                }
                
                // Vibrate on mobile if supported
                if (navigator.vibrate) {
                    navigator.vibrate([200, 100, 200]); // Vibrate pattern
                    console.log('üì≥ Vibration triggered');
                }
                
                // Check if already connected (sometimes state changes before we receive answer)
                if (peerConnection.connectionState === 'connected') {
                    console.log('‚úÖ Already connected, starting timer');
                    currentCallState = 'connected';
                    if (statusEl) {
                        statusEl.textContent = 'Connected';
                        statusEl.style.color = '';
                    }
                    if (!callTimerInterval) startCallTimer();
                }
                
            } else if (signal.type === 'ice') {
                await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
            } else if (signal.type === 'hangup') {
                debugLog('CALL-SIGNAL', `‚ùå Received hangup signal from user: ${fromUserId}`);
                debugLog('CALL-SIGNAL', `Current call state: ${currentCallState}`);
                
                // Other party hung up - end call on this side
                if (currentCallState === 'calling' || currentCallState === 'ringing' || currentCallState === 'connecting' || currentCallState === 'connected') {
                    debugLog('CALL-SIGNAL', 'Ending call due to remote hangup');
                    hangupCall('Other party ended call');
                } else {
                    debugLog('CALL-SIGNAL', `Ignoring hangup - not in active call (state: ${currentCallState})`);
                }
            }
        }

        function startSignalPolling() {
            // Don't create duplicate intervals
            if (signalPollInterval) {
                console.log('üì° Signal polling already running');
                return;
            }
            // Fast polling (300ms) for real-time signal delivery
            signalPollInterval = setInterval(pollSignals, 300);
            console.log('üì° Signal polling started (300ms interval)');
        }

        function stopSignalPolling() {
            if (signalPollInterval) {
                clearInterval(signalPollInterval);
                signalPollInterval = null;
            }
        }

        // ========== Incoming Call ==========
        
        async function handleIncomingCall(offer, callerUserId) {
            debugLog('CALL-RECEIVE', '========== INCOMING CALL ==========');
            debugLog('CALL-RECEIVE', `Device: ${deviceInfo.isMobile ? 'MOBILE' : 'PC'} | ${deviceInfo.os} ${deviceInfo.browser}`);
            debugLog('CALL-RECEIVE', `From user: ${callerUserId} (type: ${typeof callerUserId})`);
            debugLog('CALL-RECEIVE', `Current user: ${currentUser?.id} (${currentUser?.username}) Role: ${currentUser?.role}`);
            debugLog('CALL-RECEIVE', `Call ID: ${offer.call_id}`);
            debugLog('CALL-RECEIVE', `Current state BEFORE: ${currentCallState}`);
            debugLog('CALL-RECEIVE', `Screen: ${window.innerWidth}x${window.innerHeight}`);
            
            // If already in a call, reject this incoming call
            if (currentCallState === 'connected' || currentCallState === 'calling') {
                debugLog('CALL-RECEIVE', `‚ö†Ô∏è Already in a call (state: ${currentCallState}), rejecting incoming call`);
                return;
            }
            
            currentCallId = offer.call_id;
            currentCallState = 'ringing';
            debugLog('CALL-RECEIVE', `State changed to: ringing (Call ID: ${currentCallId})`);
            
            // Get caller name
            let callerName = 'User';
            if (currentUser?.role === 'administrator') {
                callerName = `User ${callerUserId}`;
            }
            
            debugLog('CALL-RECEIVE', `Caller name: ${callerName}`);
            
            // Store offer for answer
            window.pendingOffer = offer;
            window.pendingCallerId = callerUserId;
            debugLog('CALL-RECEIVE', `Stored pendingCallerId: ${window.pendingCallerId} (type: ${typeof window.pendingCallerId})`);
            
            // Show incoming call with robust retry system
            debugLog('CALL-RECEIVE', 'Calling showIncomingCallModal...');
            showIncomingCallModal(callerName);
            
            debugLog('CALL-RECEIVE', '========================================');
        }
        
        /**
         * Robust modal display with retries and multiple fallbacks
         * Ensures incoming calls are NEVER missed
         */
        function showIncomingCallModal(callerName, attempt = 1) {
            const maxAttempts = 3;
            
            debugLog('MODAL', `Attempt ${attempt}/${maxAttempts} to show incoming call modal`);
            debugLog('MODAL', `Caller: ${callerName} | Device: ${deviceInfo.isMobile ? 'MOBILE' : 'PC'}`);
            
            const modal = document.getElementById('incoming-call-modal');
            const nameEl = document.getElementById('incoming-caller-name');
            
            debugLog('MODAL', `Modal element: ${!!modal}, Name element: ${!!nameEl}`);
            
            // Reset modal state first (in case it's still set from previous call)
            if (modal && attempt === 1) {
                debugLog('MODAL', 'Resetting modal state from previous call...');
                debugLog('MODAL', `Current state - display: ${modal.style.display}, classList: ${modal.className}`);
                
                // Force complete reset
                modal.classList.remove('show');
                modal.removeAttribute('style'); // Remove ALL inline styles
                
                // Force browser to process the reset
                void modal.offsetHeight; // Trigger reflow
                
                debugLog('MODAL', 'Modal reset complete - all styles cleared');
            }
            
            // Check if elements exist
            if (!modal || !nameEl) {
                debugLog('MODAL', `‚ö†Ô∏è Modal elements not ready (attempt ${attempt}/${maxAttempts})`);
                
                if (attempt < maxAttempts) {
                    // Retry after 100ms
                    debugLog('MODAL', `Retrying in 100ms...`);
                    setTimeout(() => showIncomingCallModal(callerName, attempt + 1), 100);
                    return;
                } else {
                    // All retries failed - use fallbacks
                    debugLog('MODAL', '‚ùå Modal not available after retries - using fallbacks');
                    useFallbackNotification(callerName);
                    return;
                }
            }
            
            // Elements exist - show modal
            try {
                debugLog('MODAL', `Setting caller name: "${callerName} is calling..."`);
                nameEl.textContent = `${callerName} is calling...`;
                
                debugLog('MODAL', 'Adding "show" class...');
                modal.classList.add('show');
                
                // Force visibility with inline styles (override any CSS)
                debugLog('MODAL', 'Setting inline styles for visibility...');
                modal.style.cssText = 'display: flex !important; z-index: 999999 !important; visibility: visible !important;';
                
                // Small delay to ensure styles are applied
                setTimeout(() => {
                    // Verify it's actually visible
                    const computedStyle = window.getComputedStyle(modal);
                    debugLog('MODAL', `Computed style - display: ${computedStyle.display}, visibility: ${computedStyle.visibility}, z-index: ${computedStyle.zIndex}`);
                    
                    if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden') {
                        debugLog('MODAL', '‚ö†Ô∏è Modal still not visible - emergency override');
                        modal.setAttribute('style', 'display: flex !important; z-index: 999999 !important; visibility: visible !important; position: fixed !important;');
                    }
                }, 50);
                
                // Check modal position
                const rect = modal.getBoundingClientRect();
                debugLog('MODAL', `Modal position: top=${rect.top}, left=${rect.left}, width=${rect.width}, height=${rect.height}`);
                debugLog('MODAL', `Modal in viewport: ${rect.top >= 0 && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth}`);
                
                debugLog('MODAL', '‚úÖ Incoming call modal shown successfully');
                
                // Multi-sensory alerts
                debugLog('MODAL', 'Playing alert sounds and vibration...');
                playIncomingCallAlert();
                
            } catch (error) {
                console.error('‚ùå Error showing modal:', error);
                useFallbackNotification(callerName);
            }
        }
        
        /**
         * Multi-sensory alert for incoming calls
         */
        function playIncomingCallAlert() {
            // 1. Vibration (mobile)
            if (navigator.vibrate) {
                // Long vibration pattern for incoming call
                navigator.vibrate([500, 200, 500, 200, 500, 200, 500]);
                console.log('üì≥ Vibration triggered');
            }
            
            // 2. Audio notification (beep pattern)
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 880; // A5 note
                oscillator.type = 'sine';
                
                // Beep pattern: beep-beep-pause-beep-beep
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + 0.15);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + 0.35);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + 0.6);
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + 0.75);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + 0.8);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.0);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 1.0);
                
                console.log('üîî Incoming call sound played');
            } catch (error) {
                console.log('‚ö†Ô∏è Could not play sound:', error);
            }
            
            // 3. Page title flash (if user has app in background)
            const originalTitle = document.title;
            let flashCount = 0;
            const flashInterval = setInterval(() => {
                document.title = flashCount % 2 === 0 ? 'üìû INCOMING CALL!' : originalTitle;
                flashCount++;
                if (flashCount > 10) {
                    clearInterval(flashInterval);
                    document.title = originalTitle;
                }
            }, 500);
        }
        
        /**
         * Fallback notification methods when modal fails
         */
        function useFallbackNotification(callerName) {
            console.log('üîî Using fallback notification methods');
            
            // Fallback 1: Browser Notification API
            if ('Notification' in window) {
                if (Notification.permission === 'granted') {
                    new Notification(`Incoming call from ${callerName}`, {
                        body: 'Click to answer',
                        icon: '/static/phone-icon.png',
                        requireInteraction: true,
                        tag: 'incoming-call',
                        vibrate: [500, 200, 500]
                    });
                    console.log('‚úÖ Browser notification shown');
                    return;
                } else if (Notification.permission !== 'denied') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            useFallbackNotification(callerName);
                        }
                    });
                }
            }
            
            // Fallback 2: Alert (always works, blocks until dismissed)
            console.log('‚ö†Ô∏è Using alert() as last resort');
            const answer = confirm(`INCOMING CALL from ${callerName}\n\nClick OK to answer, Cancel to reject.`);
            
            if (answer) {
                answerCall();
            } else {
                rejectCall();
            }
        }

        // Make functions globally accessible for onclick handlers
        window.answerCall = async function() {
            debugLog('CALL-ANSWER', '========== ANSWERING CALL ==========');
            debugLog('CALL-ANSWER', `Device: ${deviceInfo.isMobile ? 'MOBILE' : 'PC'} | ${deviceInfo.os} ${deviceInfo.browser}`);
            debugLog('CALL-ANSWER', `Button clicked! pendingCallerId: ${window.pendingCallerId}`);
            debugLog('CALL-ANSWER', `Call ID: ${currentCallId}, State: ${currentCallState}`);
            
            // Clear any existing timeout
            if (callTimeoutTimer) {
                clearTimeout(callTimeoutTimer);
                callTimeoutTimer = null;
                debugLog('CALL-ANSWER', 'Cleared call timeout');
            }
            
            // Hide incoming call modal completely
            debugLog('CALL-ANSWER', 'Hiding incoming call modal...');
            const incomingModal = document.getElementById('incoming-call-modal');
            if (incomingModal) {
                const wasVisible = incomingModal.classList.contains('show');
                incomingModal.classList.remove('show');
                // Set to display none for now (will be reset on next call)
                incomingModal.style.cssText = 'display: none !important;';
                debugLog('CALL-ANSWER', `‚úÖ Modal hidden (was visible: ${wasVisible})`);
            } else {
                debugLog('CALL-ANSWER', '‚ö†Ô∏è Incoming modal not found!');
            }
            
            try {
                // Get microphone permission
                debugLog('CALL-ANSWER', 'Requesting microphone permission...');
                const micStartTime = Date.now();
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const micDuration = Date.now() - micStartTime;
                debugLog('CALL-ANSWER', `‚úÖ Microphone granted in ${micDuration}ms`);
                debugLog('CALL-ANSWER', `Audio tracks: ${localStream.getAudioTracks().length}`);
                
                // Set up peer connection - unified for all scenarios
                remoteUserId = window.pendingCallerId; // Track who called us
                debugLog('CALL-ANSWER', `remoteUserId set to: ${remoteUserId}`);
                debugLog('CALL-ANSWER', `Setting up peer connection with ${window.pendingCallerId}...`);
                await setupPeerConnection(window.pendingCallerId);
                
                // Set remote description (offer)
                debugLog('CALL-ANSWER', 'Setting remote description (offer)...');
                await peerConnection.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: window.pendingOffer.sdp
                }));
                debugLog('CALL-ANSWER', '‚úÖ Remote description set');
                
                // Create answer (with video support)
                debugLog('CALL-ANSWER', 'Creating answer...');
                const answerStartTime = Date.now();
                const answer = await peerConnection.createAnswer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                await peerConnection.setLocalDescription(answer);
                const answerDuration = Date.now() - answerStartTime;
                debugLog('CALL-ANSWER', `‚úÖ Answer created in ${answerDuration}ms`);
                
                // Send answer back
                debugLog('CALL-ANSWER', `Sending answer to: ${window.pendingCallerId}`);
                debugLog('CALL-ANSWER', `Call ID: ${currentCallId}`);
                debugLog('CALL-ANSWER', `Current user: ${currentUser?.id} (${currentUser?.username}) Role: ${currentUser?.role}`);
                
                await sendSignal(window.pendingCallerId, {
                    type: 'answer',
                    sdp: answer.sdp,
                    call_id: currentCallId
                });
                debugLog('CALL-ANSWER', '‚úÖ Answer signal sent successfully!');
                
                // Update call status in backend
                await fetch(`${API_URL}/call/answer`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        call_id: currentCallId,
                        caller_id: window.pendingCallerId
                    })
                });
                
                // Show active call UI
                currentCallState = 'connecting';  // Set to connecting, not connected yet!
                
                // Get caller name
                let callerName = 'User';
                if (currentUser?.role === 'administrator') {
                    // Admin answering user call
                    callerName = `User ${window.pendingCallerId}`;
                } else {
                    // User answering admin call
                    callerName = 'Admin';
                }
                
                document.getElementById('active-call-name').textContent = callerName;
                document.getElementById('active-call-status').textContent = 'Connecting...';
                
                // Ensure active call modal is visible
                const activeModal = document.getElementById('active-call-modal');
                if (activeModal) {
                    activeModal.classList.add('show');
                    activeModal.style.display = 'flex';
                    activeModal.style.zIndex = '10000';
                    console.log('‚úÖ Active call modal shown');
                }
                
                startCallTimer();
                startSignalPolling();
                
            } catch (error) {
                console.error('Failed to answer call:', error);
                showError('Failed to answer call');
                rejectCall();
            }
        }

        window.rejectCall = async function() {
            console.log('‚ùå Rejecting call');
            
            // Hide incoming call modal properly
            const incomingModal = document.getElementById('incoming-call-modal');
            if (incomingModal) {
                incomingModal.classList.remove('show');
                incomingModal.style.cssText = 'display: none !important;';
                debugLog('CALL-REJECT', 'Incoming modal hidden');
            }
            
            if (currentCallId) {
                await fetch(`${API_URL}/call/reject`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ call_id: currentCallId })
                });
            }
            
            cleanupCall();
        }

        // ========== Call Controls ==========
        
        window.hangupCall = async function(reason = 'Call ended') {
            debugLog('CALL-HANGUP', 'üì¥ ========== HANGING UP CALL ==========');
            debugLog('CALL-HANGUP', `Reason: ${reason}`);
            debugLog('CALL-HANGUP', `Call state: ${currentCallState}`);
            debugLog('CALL-HANGUP', `Remote user: ${remoteUserId}`);
            
            const duration = callStartTime ? Math.floor((Date.now() - callStartTime) / 1000) : 0;
            
            // Send hangup signal to other party (BEFORE cleanup)
            if (remoteUserId && currentCallId && reason !== 'Other party ended call') {
                debugLog('CALL-HANGUP', `Sending hangup signal to user: ${remoteUserId}`);
                try {
                    await sendSignal(remoteUserId, {
                        type: 'hangup',
                        call_id: currentCallId,
                        reason: reason
                    });
                    debugLog('CALL-HANGUP', '‚úÖ Hangup signal sent');
                } catch (error) {
                    debugLog('CALL-HANGUP', '‚ùå Failed to send hangup signal:', error);
                }
            } else {
                debugLog('CALL-HANGUP', `No hangup signal sent (remoteUserId: ${remoteUserId}, reason: ${reason})`);
            }
            
            // Notify backend
            if (currentCallId) {
                await fetch(`${API_URL}/call/hangup`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        call_id: currentCallId,
                        duration: duration
                    })
                });
                debugLog('CALL-HANGUP', 'Backend notified');
            }
            
            // Hide both modals properly (clear classes AND inline styles)
            const activeModal = document.getElementById('active-call-modal');
            if (activeModal) {
                activeModal.classList.remove('show');
                activeModal.style.cssText = 'display: none !important;';
                debugLog('CLEANUP', 'Active call modal hidden');
            }
            
            const incomingModal = document.getElementById('incoming-call-modal');
            if (incomingModal) {
                incomingModal.classList.remove('show');
                incomingModal.style.cssText = 'display: none !important;';
                debugLog('CLEANUP', 'Incoming modal hidden');
            }
            
            if (reason && reason !== 'Call ended') {
                showError(reason);
            }
            
            cleanupCall();
            
            const callBtn = document.getElementById('call-admin-btn');
            if (callBtn) callBtn.disabled = false;
        }

        window.toggleMute = function() {
            if (!localStream) return;
            
            const audioTrack = localStream.getAudioTracks()[0];
            if (!audioTrack) return;
            
            audioTrack.enabled = !audioTrack.enabled;
            
            const muteBtn = document.getElementById('mute-btn');
            if (audioTrack.enabled) {
                muteBtn.textContent = 'üîá';
                muteBtn.classList.remove('active');
            } else {
                muteBtn.textContent = 'üîä';
                muteBtn.classList.add('active');
            }
        }

        window.toggleVideo = async function() {
            console.log('üìπ Toggle video clicked');
            
            if (!localStream) {
                console.error('‚ùå No local stream');
                return;
            }
            
            const videoBtn = document.getElementById('video-btn');
            const videoContainer = document.getElementById('video-container');
            const audioView = document.getElementById('audio-view');
            const localVideo = document.getElementById('local-video');
            
            const videoTrack = localStream.getVideoTracks()[0];
            console.log('Current video track:', videoTrack);
            
            if (videoTrack) {
                // Video exists, toggle it
                videoTrack.enabled = !videoTrack.enabled;
                console.log('Video track enabled:', videoTrack.enabled);
                
                if (videoTrack.enabled) {
                    // Ensure local video element has stream
                    if (!localVideo.srcObject) {
                        localVideo.srcObject = localStream;
                        console.log('üìπ Local video srcObject set');
                    }
                    videoContainer.style.display = 'block';
                    audioView.style.display = 'none';
                    videoBtn.classList.add('active');
                    console.log('‚úÖ Video enabled and displayed');
                } else {
                    videoContainer.style.display = 'none';
                    audioView.style.display = 'flex';
                    videoBtn.classList.remove('active');
                    console.log('Video disabled');
                }
            } else {
                // No video track yet, request camera permission
                console.log('üé• Requesting camera permission...');
                showSuccess('Click "Allow" to enable your camera');
                
                try {
                    // Request ONLY video, keep existing audio
                    const videoStream = await navigator.mediaDevices.getUserMedia({ 
                        video: {
                            width: { ideal: 640, max: 1280 },
                            height: { ideal: 480, max: 720 },
                            facingMode: 'user'
                        } 
                    });
                    
                    console.log('‚úÖ Camera permission granted');
                    
                    // Add video track to existing stream (keep audio!)
                    const videoTrack = videoStream.getVideoTracks()[0];
                    localStream.addTrack(videoTrack);
                    
                    console.log('üé§ Audio preserved, video added');
                    
                    // Update local video element
                    localVideo.srcObject = localStream;
                    
                    // Replace tracks in peer connection
                    if (peerConnection) {
                        const senders = peerConnection.getSenders();
                        const videoTrack = localStream.getVideoTracks()[0];
                        
                        // Find video sender
                        const videoSender = senders.find(s => s.track?.kind === 'video');
                        
                        if (videoSender) {
                            // Replace existing video track
                            await videoSender.replaceTrack(videoTrack);
                            console.log('üìπ Replaced existing video track');
                        } else {
                            // Add new video track
                            peerConnection.addTrack(videoTrack, localStream);
                            console.log('üìπ Added new video track');
                            
                            // RENEGOTIATE - create new offer with video
                            const offer = await peerConnection.createOffer({
                                offerToReceiveAudio: true,
                                offerToReceiveVideo: true
                            });
                            await peerConnection.setLocalDescription(offer);
                            
                            // Send new offer to peer
                            const targetUserId = currentUser.role === 'administrator' ? window.pendingCallerId : adminId;
                            console.log('üéØ Target user for renegotiation:', targetUserId, 'Role:', currentUser.role);
                            console.log('üìù Call ID:', currentCallId);
                            
                            if (targetUserId) {
                                const signalData = {
                                    type: 'offer',
                                    sdp: offer.sdp,
                                    call_id: currentCallId
                                };
                                console.log('üì§ Sending renegotiation offer:', signalData);
                                
                                await sendSignal(targetUserId, signalData);
                                console.log('‚úÖ Renegotiation offer sent successfully');
                            } else {
                                console.error('‚ùå No target user ID for renegotiation!');
                            }
                        }
                    }
                    
                    // Show video UI
                    videoContainer.style.display = 'block';
                    audioView.style.display = 'none';
                    videoBtn.classList.add('active');
                    
                    console.log('‚úÖ Video enabled and shared');
                } catch (error) {
                    console.error('Failed to get video:', error);
                    showError('Camera access denied or not available');
                }
            }
        }

        function swapVideos() {
            console.log('üîÑ Swapping video windows');
            
            const localVideo = document.getElementById('local-video');
            const remoteVideo = document.getElementById('remote-video');
            
            if (!localVideo || !remoteVideo) return;
            
            // Swap classes to swap positioning and sizing
            const tempClass = localVideo.className;
            localVideo.className = remoteVideo.className;
            remoteVideo.className = tempClass;
            
            // Keep muted states: local always muted, remote never muted
            localVideo.muted = true;  // Always mute your own video
            remoteVideo.muted = false; // Never mute remote person
            
            console.log('‚úÖ Video windows swapped - Local is now:', localVideo.className);
        }
        
        // Toggle fullscreen on video element
        function toggleFullscreen(videoElement) {
            console.log('üñ•Ô∏è Toggle fullscreen');
            
            // Check both standard and webkit fullscreen
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
            
            if (!isFullscreen) {
                // Enter fullscreen
                console.log('üì± Attempting fullscreen...');
                
                // Try different fullscreen methods
                if (videoElement.requestFullscreen) {
                    videoElement.requestFullscreen().catch(err => {
                        console.error('Fullscreen error:', err);
                        // Fallback: Try webkit
                        if (videoElement.webkitRequestFullscreen) {
                            videoElement.webkitRequestFullscreen();
                        }
                    });
                } else if (videoElement.webkitRequestFullscreen) { // iOS Safari
                    videoElement.webkitRequestFullscreen();
                } else if (videoElement.webkitEnterFullscreen) { // iOS video element specific
                    videoElement.webkitEnterFullscreen();
                } else if (videoElement.mozRequestFullScreen) { // Firefox
                    videoElement.mozRequestFullScreen();
                } else if (videoElement.msRequestFullscreen) { // IE/Edge
                    videoElement.msRequestFullscreen();
                } else {
                    console.warn('‚ö†Ô∏è Fullscreen not supported on this device');
                    showError('Fullscreen not supported on this device');
                }
                console.log('‚úÖ Entered fullscreen');
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { // Safari
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) { // Firefox
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) { // IE/Edge
                    document.msExitFullscreen();
                }
                console.log('‚úÖ Exited fullscreen');
            }
        }

        function cleanupCall() {
            debugLog('CLEANUP', '========== CLEANING UP CALL ==========');
            
            if (callTimerInterval) {
                clearInterval(callTimerInterval);
                callTimerInterval = null;
                debugLog('CLEANUP', 'Call timer cleared');
            }
            
            // Clear call timeout if still active
            if (callTimeoutTimer) {
                clearTimeout(callTimeoutTimer);
                callTimeoutTimer = null;
                debugLog('CLEANUP', 'Call timeout cleared');
            }
            
            // DON'T stop signal polling - keep it running for incoming calls!
            // stopSignalPolling();
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                debugLog('CLEANUP', 'Local stream stopped');
            }
            
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
                debugLog('CLEANUP', 'Remote stream stopped');
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                debugLog('CLEANUP', 'Peer connection closed');
            }
            
            // Clear pending call data for fresh state
            window.pendingOffer = null;
            window.pendingCallerId = null;
            remoteUserId = null; // Clear remote user tracking
            debugLog('CLEANUP', 'Pending call data cleared');
            
            currentCallId = null;
            currentCallState = null;
            callStartTime = null;
            debugLog('CLEANUP', 'Call state reset');
            
            // Reset video UI
            const videoContainer = document.getElementById('video-container');
            const audioView = document.getElementById('audio-view');
            const videoBtn = document.getElementById('video-btn');
            const localVideo = document.getElementById('local-video');
            const remoteVideo = document.getElementById('remote-video');
            
            if (videoContainer) videoContainer.style.display = 'none';
            if (audioView) audioView.style.display = 'flex';
            if (videoBtn) videoBtn.classList.remove('active');
            if (localVideo) localVideo.srcObject = null;
            if (remoteVideo) remoteVideo.srcObject = null;
            
            updateMyStatus('online');
        }

        // ========== UI Functions ==========
        
        function showCallingUI() {
            const adminName = localStorage.getItem(`admin_name_for_user_${currentUser.id}`) || 'Ken';
            
            document.getElementById('active-call-name').textContent = adminName;
            document.getElementById('active-call-status').textContent = 'Calling...';
            document.getElementById('call-timer').textContent = '00:00';
            document.getElementById('active-call-modal').classList.add('show');
        }

        function startCallTimer() {
            callStartTime = Date.now();
            
            callTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                
                const timerDisplay = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                const timerEl = document.getElementById('call-timer');
                if (timerEl) timerEl.textContent = timerDisplay;
            }, 1000);
        }

        // ========== Missed Calls ==========
        
        async function loadMissedCalls() {
            if (!currentUser || currentUser.role !== 'administrator') return;
            
            try {
                const response = await fetch(`${API_URL}/call/missed`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const missedCalls = await response.json();
                
                const unseenCount = missedCalls.filter(call => !call.seen).length;
                const badge = document.getElementById('missed-calls-count');
                const indicator = document.getElementById('missed-calls-indicator');
                
                if (unseenCount > 0) {
                    badge.textContent = unseenCount;
                    badge.style.display = 'flex';
                    indicator.style.display = 'block';
                } else {
                    badge.style.display = 'none';
                    if (missedCalls.length === 0) {
                        indicator.style.display = 'none';
                    }
                }
                
                return missedCalls;
                
            } catch (error) {
                console.error('Failed to load missed calls:', error);
                return [];
            }
        }

        async function showMissedCalls() {
            const missedCalls = await loadMissedCalls();
            
            if (missedCalls.length === 0) {
                showSuccess('No missed calls');
                return;
            }
            
            let html = '<div class="missed-calls-list">';
            
            for (const call of missedCalls) {
                const callDate = parseTimestamp(call.call_time);
                const time = callDate ? callDate.toLocaleString() : 'Unknown time';
                const seenClass = call.seen ? 'seen' : '';
                
                html += `
                    <div class="missed-call-item ${seenClass}">
                        <div>
                            <strong>${call.caller_username}</strong><br>
                            <small>${time}</small>
                        </div>
                        <button class="btn-small" onclick="markCallSeen(${call.id})">‚úì</button>
                    </div>
                `;
            }
            
            html += '</div>';
            
            showConfirmModal('Missed Calls', html, () => {
                missedCalls.forEach(call => markCallSeen(call.id));
            }, 'Mark All Seen', 'Close');
        }

        async function markCallSeen(callId) {
            try {
                await fetch(`${API_URL}/call/mark-seen/${callId}`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                await loadMissedCalls();
                
            } catch (error) {
                console.error('Failed to mark call as seen:', error);
            }
        }
        
        console.log('üìû Voice call system loaded');
    </script>
</body>
</html>
